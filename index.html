<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure Game</title>
    <link rel="stylesheet" href="css/common.css">
    <style>
        body { padding: 0; }

        .game-container {
            display: grid;
            grid-template-columns: 1fr 5px 400px;
            grid-template-rows: 1fr auto;
            height: 100vh;
            gap: 0;
        }

        .resize-handle {
            width: 5px;
            background: #333;
            cursor: col-resize;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: #4a9eff;
        }

        /* シーンエリア */
        .scene-area {
            background: #111;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        .scene-image {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 20px;
            position: relative;
        }

        .scene-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            cursor: pointer;
        }

        .scene-placeholder {
            color: #666;
            font-size: 1.2rem;
            text-align: center;
        }

        .scene-loading {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #4a9eff;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 0.85rem;
            z-index: 10;
        }

        .scene-dialogue {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 15px 20px;
            font-size: 1.35rem;
            line-height: 1.8;
            z-index: 5;
            display: none;
        }

        .scene-dialogue.font-large {
            font-size: 1.6rem;
            line-height: 1.9;
        }

        .scene-dialogue.font-small {
            font-size: 1.1rem;
            line-height: 1.7;
        }

        .scene-dialogue .char-name {
            color: #4a9eff;
            font-weight: bold;
            margin-right: 8px;
        }

        .scene-thumbnails {
            display: flex;
            gap: 8px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            overflow-x: auto;
            flex-shrink: 0;
        }

        .scene-thumb {
            width: 60px;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            opacity: 0.6;
            transition: all 0.2s;
        }

        .scene-thumb:hover {
            opacity: 0.9;
        }

        .scene-thumb.active {
            border-color: #4a9eff;
            opacity: 1;
        }

        .scene-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .scene-info .char-name {
            color: #4a9eff;
            font-weight: bold;
        }

        .scene-info .place-name {
            color: #27ae60;
        }

        /* チャットエリア */
        .chat-area {
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #333;
            overflow: hidden;
            min-height: 0;
        }

        .chat-header {
            padding: 15px;
            background: #222;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-header h2 {
            margin: 0;
            color: #4a9eff;
            font-size: 1rem;
            flex: 1;
        }

        .font-size-btns {
            display: flex;
            gap: 4px;
        }

        .font-size-btns button {
            background: #444;
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .font-size-btns button:hover {
            background: #555;
        }

        .font-size-btns button.active {
            background: #4a9eff;
        }

        /* 中（デフォルト）: 1.35rem */
        .chat-messages .message {
            font-size: 1.35rem;
            line-height: 1.8;
        }

        .chat-messages .message.narration {
            font-size: 1.25rem;
        }

        /* 大: 1.6rem */
        .chat-messages.font-large .message {
            font-size: 1.6rem;
            line-height: 1.9;
        }

        .chat-messages.font-large .message.narration {
            font-size: 1.5rem;
        }

        /* 小: 1.1rem */
        .chat-messages.font-small .message {
            font-size: 1.1rem;
            line-height: 1.7;
        }

        .chat-messages.font-small .message.narration {
            font-size: 1.05rem;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }

        .message {
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .message.user {
            background: #4a9eff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            background: #333;
            color: #e0e0e0;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .message.system {
            background: #2a2a2a;
            color: #888;
            align-self: center;
            font-size: 0.85rem;
            font-style: italic;
        }

        .message.narration {
            background: transparent;
            color: #c9a0dc;
            align-self: stretch;
            max-width: 100%;
            font-size: 0.9rem;
            line-height: 1.8;
            padding: 15px;
            border-left: 3px solid #9b59b6;
        }

        .chat-input-area {
            padding: 15px;
            background: #222;
            border-top: 1px solid #333;
            display: flex;
            gap: 10px;
        }

        .chat-input-area input {
            flex: 1;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 20px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.95rem;
        }

        .chat-input-area input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .chat-input-area button {
            padding: 12px 20px;
            border-radius: 20px;
        }

        /* コントロールバー */
        .control-bar {
            grid-column: 1 / 4;
            background: #1a1a1a;
            border-top: 1px solid #333;
            padding: 15px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            color: #888;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .control-group select {
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.9rem;
            min-width: 150px;
        }

        .control-actions {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        /* 設定パネル */
        .settings-toggle {
            position: fixed;
            top: 10px;
            right: 420px;
            background: #333;
            border: none;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 100;
        }

        .settings-toggle:hover {
            background: #444;
        }

        .settings-panel {
            position: fixed;
            top: 50px;
            right: 420px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            width: 350px;
            display: none;
            z-index: 100;
        }

        .settings-panel.active {
            display: block;
        }

        .settings-panel h3 {
            margin: 0 0 15px 0;
            color: #4a9eff;
            font-size: 1rem;
        }

        .settings-panel .form-group {
            margin-bottom: 12px;
        }

        .settings-panel .form-group label {
            display: block;
            color: #888;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }

        .settings-panel .form-group input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.85rem;
        }

        .settings-panel .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #settings-status {
            margin-top: 10px;
            font-size: 0.8rem;
        }

        /* レスポンシブ */
        @media (max-width: 900px) {
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: 50vh 1fr auto;
            }
            .chat-area {
                border-left: none;
                border-top: 1px solid #333;
            }
            .settings-toggle {
                right: 10px;
            }
            .settings-panel {
                right: 10px;
                width: calc(100% - 40px);
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- シーンエリア -->
    <div class="scene-area">
        <div class="scene-info">
            <span class="char-name" id="current-char">キャラクター未選択</span>
            <span style="color: #666;"> @ </span>
            <span class="place-name" id="current-place">場所未選択</span>
        </div>
        <div class="scene-image" id="scene-image">
            <div class="scene-placeholder">
                キャラクターと場所を選択してください<br>
                <small style="color: #555;">設定ボタンからGASデータを読み込んでください</small>
            </div>
            <div class="scene-dialogue" id="scene-dialogue"></div>
        </div>
        <div class="scene-thumbnails" id="scene-thumbnails" style="display: none;"></div>
    </div>

    <!-- リサイズハンドル -->
    <div class="resize-handle" id="resize-handle"></div>

    <!-- チャットエリア -->
    <div class="chat-area" id="chat-area">
        <div class="chat-header">
            <h2 id="chat-title">チャット</h2>
            <div class="font-size-btns">
                <button onclick="setFontSize('small')" id="font-small">小</button>
                <button onclick="setFontSize('normal')" id="font-normal" class="active">中</button>
                <button onclick="setFontSize('large')" id="font-large">大</button>
            </div>
            <button class="btn btn-small" onclick="clearChat()" style="background:#555;">クリア</button>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="message system">キャラクターを選択するとチャットできます</div>
        </div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="メッセージを入力..." onkeydown="if(event.key==='Enter')sendMessage()">
            <button class="btn btn-primary" onclick="sendMessage()">送信</button>
        </div>
    </div>

    <!-- コントロールバー -->
    <div class="control-bar">
        <div class="control-group">
            <label>キャラクター:</label>
            <select id="character" onchange="onCharacterChange()">
                <option value="">-- 選択 --</option>
            </select>
        </div>
        <div class="control-group">
            <label>場所:</label>
            <select id="place" onchange="onPlaceChange()">
                <option value="">-- 選択 --</option>
            </select>
        </div>
        <div class="control-group">
            <label>アクション:</label>
            <select id="action">
                <option value="">-- 選択 --</option>
            </select>
        </div>
        <div class="control-actions">
            <button class="btn btn-generate" onclick="executeAction()" id="action-btn">アクション実行</button>
            <button class="btn btn-primary" onclick="generateSceneImage()" id="scene-btn">シーン生成</button>
        </div>
    </div>
</div>

<!-- 設定パネル -->
<button class="settings-toggle" onclick="toggleSettings()">設定</button>
<div class="settings-panel" id="settings-panel">
    <h3>設定</h3>
    <div class="form-group">
        <label>GAS URL:</label>
        <input type="text" id="gasUrl" placeholder="https://script.google.com/macros/s/xxx/exec">
    </div>
    <div class="form-group">
        <label>Runware API Key:</label>
        <input type="password" id="apiKey" placeholder="画像生成用">
    </div>
    <div class="form-group">
        <label>OpenRouter API Key:</label>
        <input type="password" id="chatApiKey" placeholder="チャット用">
    </div>
    <div class="form-group">
        <label>チャットモデル:</label>
        <select id="chatModel">
            <option value="x-ai/grok-4.1-fast">Grok 4.1 Fast</option>
            <option value="google/gemini-2.0-flash-001">Gemini 2.0 Flash</option>
            <option value="anthropic/claude-3.5-haiku">Claude 3.5 Haiku</option>
            <option value="openai/gpt-4o-mini">GPT-4o Mini</option>
        </select>
    </div>
    <div class="btn-row">
        <button class="btn btn-primary" onclick="loadAllFromGas()">GAS読み込み</button>
        <button class="btn btn-save" onclick="doSaveSettings()">設定保存</button>
    </div>
    <div id="settings-status"></div>
</div>

<script src="js/constants.js"></script>
<script src="js/gas-api.js"></script>
<script src="js/runware-api.js"></script>
<script src="js/storage.js"></script>
<script src="js/data-parser.js"></script>
<script src="js/ui-utils.js"></script>
<script>
    // ストレージキー
    const GAME_DATA_KEY = 'adventure_game_data';
    const CHAT_API_KEY = 'openrouter_api_key';
    const CHAT_MODEL_KEY = 'openrouter_model';

    // データストア
    let models = {};
    let characters = [];
    let places = [];
    let actions = [];
    let chatHistory = [];
    let currentSceneUrl = '';
    let generatedImages = [];
    let currentImageIndex = 0;

    // 初期化
    document.addEventListener('DOMContentLoaded', () => {
        const settings = loadSettings(STORAGE_KEYS.GAS_URL, STORAGE_KEYS.API_KEY);
        if (settings.gasUrl) document.getElementById('gasUrl').value = settings.gasUrl;
        if (settings.apiKey) document.getElementById('apiKey').value = settings.apiKey;

        const chatApiKey = localStorage.getItem(CHAT_API_KEY);
        if (chatApiKey) document.getElementById('chatApiKey').value = chatApiKey;

        const chatModel = localStorage.getItem(CHAT_MODEL_KEY);
        if (chatModel) document.getElementById('chatModel').value = chatModel;

        // 保存された文字サイズを復元
        const savedFontSize = localStorage.getItem('chat_font_size') || 'normal';
        setFontSize(savedFontSize);

        // 保存されたチャット幅を復元
        const savedChatWidth = localStorage.getItem('chat_width');
        if (savedChatWidth) {
            document.querySelector('.game-container').style.gridTemplateColumns = `1fr 5px ${savedChatWidth}px`;
        }

        loadCachedData();
        initResize();
    });

    // リサイズ機能
    function initResize() {
        const handle = document.getElementById('resize-handle');
        const container = document.querySelector('.game-container');
        const chatArea = document.getElementById('chat-area');
        let isResizing = false;

        handle.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerRect = container.getBoundingClientRect();
            const newChatWidth = containerRect.right - e.clientX;
            const minWidth = 250;
            const maxWidth = containerRect.width - 300;

            if (newChatWidth >= minWidth && newChatWidth <= maxWidth) {
                container.style.gridTemplateColumns = `1fr 5px ${newChatWidth}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                // 幅を保存
                const cols = container.style.gridTemplateColumns;
                const match = cols.match(/(\d+)px$/);
                if (match) {
                    localStorage.setItem('chat_width', match[1]);
                }
            }
        });
    }

    // 文字サイズ切り替え
    function setFontSize(size) {
        const messagesDiv = document.getElementById('chat-messages');
        const dialogueDiv = document.getElementById('scene-dialogue');
        messagesDiv.classList.remove('font-small', 'font-large');
        if (dialogueDiv) dialogueDiv.classList.remove('font-small', 'font-large');

        document.querySelectorAll('.font-size-btns button').forEach(btn => btn.classList.remove('active'));

        if (size === 'small') {
            messagesDiv.classList.add('font-small');
            if (dialogueDiv) dialogueDiv.classList.add('font-small');
            document.getElementById('font-small').classList.add('active');
        } else if (size === 'large') {
            messagesDiv.classList.add('font-large');
            if (dialogueDiv) dialogueDiv.classList.add('font-large');
            document.getElementById('font-large').classList.add('active');
        } else {
            document.getElementById('font-normal').classList.add('active');
        }

        localStorage.setItem('chat_font_size', size);
    }

    function toggleSettings() {
        document.getElementById('settings-panel').classList.toggle('active');
    }

    function doSaveSettings() {
        const gasUrl = document.getElementById('gasUrl').value.trim();
        const apiKey = document.getElementById('apiKey').value.trim();
        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        const chatModel = document.getElementById('chatModel').value;

        saveSettings(STORAGE_KEYS.GAS_URL, STORAGE_KEYS.API_KEY, gasUrl, apiKey);
        if (chatApiKey) localStorage.setItem(CHAT_API_KEY, chatApiKey);
        if (chatModel) localStorage.setItem(CHAT_MODEL_KEY, chatModel);

        showSettingsStatus('設定を保存しました');
    }

    function showSettingsStatus(msg, isError = false) {
        const el = document.getElementById('settings-status');
        el.textContent = msg;
        el.style.color = isError ? '#e74c3c' : '#27ae60';
        setTimeout(() => el.textContent = '', 3000);
    }

    function saveCachedData() {
        localStorage.setItem(GAME_DATA_KEY, JSON.stringify({ models, characters, places, actions }));
    }

    function loadCachedData() {
        try {
            const cached = localStorage.getItem(GAME_DATA_KEY);
            if (cached) {
                const data = JSON.parse(cached);
                models = data.models || {};
                characters = data.characters || [];
                places = data.places || [];
                actions = data.actions || [];
                updateAllSelects();
            }
        } catch (e) {
            console.error('Cache load error:', e);
        }
    }

    async function loadAllFromGas() {
        const baseUrl = document.getElementById('gasUrl').value.trim();
        if (!baseUrl) {
            alert('GAS URLを入力してください');
            return;
        }

        doSaveSettings();
        showSettingsStatus('読み込み中...', false);

        try {
            const [modelData, characterData, placeData, actionData] = await Promise.all([
                fetchGasData(baseUrl, 'model'),
                fetchGasData(baseUrl, 'character'),
                fetchGasData(baseUrl, 'place'),
                fetchGasData(baseUrl, 'action')
            ]);

            models = parseModels(modelData);
            characters = parseCharacters(characterData);
            places = parsePlaces(placeData);
            actions = parseActionsWithCompositions(actionData);

            saveCachedData();
            updateAllSelects();
            showSettingsStatus(`読込完了: キャラ${characters.length}, 場所${places.length}, アクション${actions.length}`);
        } catch (error) {
            console.error(error);
            showSettingsStatus('エラー: ' + error.message, true);
        }
    }

    function updateAllSelects() {
        // キャラクター
        const charSelect = document.getElementById('character');
        charSelect.innerHTML = '<option value="">-- 選択 --</option>';
        characters.forEach((char, i) => {
            charSelect.innerHTML += `<option value="${i}">${char.name}${char.series ? ' (' + char.series + ')' : ''}</option>`;
        });

        // 場所
        const placeSelect = document.getElementById('place');
        placeSelect.innerHTML = '<option value="">-- 選択 --</option>';
        places.forEach((place, i) => {
            placeSelect.innerHTML += `<option value="${i}">${place.name}</option>`;
        });

        // アクション
        const actionSelect = document.getElementById('action');
        actionSelect.innerHTML = '<option value="">-- 選択 --</option>';
        actions.forEach((action, i) => {
            actionSelect.innerHTML += `<option value="${i}">${action.name}</option>`;
        });
    }

    function onCharacterChange() {
        const idx = document.getElementById('character').value;
        const char = idx !== '' ? characters[idx] : null;

        document.getElementById('current-char').textContent = char ? char.name : 'キャラクター未選択';
        document.getElementById('chat-title').textContent = char ? `${char.name}とチャット` : 'チャット';

        if (char) {
            clearChat();
            addMessage('system', `${char.name}が現れた！`);
            if (char.profile) {
                addMessage('system', `[${char.profile}]`);
            }
        }
    }

    function onPlaceChange() {
        const idx = document.getElementById('place').value;
        const place = idx !== '' ? places[idx] : null;
        document.getElementById('current-place').textContent = place ? place.name : '場所未選択';

        if (place) {
            addMessage('system', `場所が「${place.name}」に変わった`);
        }
    }

    function getFirstModel() {
        return Object.keys(models)[0] || null;
    }

    function selectBestComposition(compositions) {
        if (!compositions || compositions.length === 0) return null;
        const best = compositions.find(c => c.quality === 'BEST' || c.quality === 'best');
        if (best) return best;
        const good = compositions.find(c => c.quality === 'Good' || c.quality === 'good');
        if (good) return good;
        return compositions[0];
    }

    function selectTopCompositions(compositions, count = 3) {
        if (!compositions || compositions.length === 0) return [];

        // 優先度でソート
        const priority = { 'BEST': 0, 'best': 0, 'Good': 1, 'good': 1 };
        const sorted = [...compositions].sort((a, b) => {
            const pa = priority[a.quality] ?? 2;
            const pb = priority[b.quality] ?? 2;
            return pa - pb;
        });

        return sorted.slice(0, count);
    }

    function buildScenePrompt() {
        const charIdx = document.getElementById('character').value;
        const placeIdx = document.getElementById('place').value;
        const modelId = getFirstModel();
        const model = models[modelId] || {};
        const char = charIdx !== '' ? characters[charIdx] : null;
        const place = placeIdx !== '' ? places[placeIdx] : null;
        const action = actions[0] || {};
        const comp = selectBestComposition(action.compositions);

        const parts = [
            model.qualityPositive || '',
            char?.tag || '',
            place?.tag || '',
            action.prompt || '',
            comp?.tag || comp?.name || 'front view',
            place?.additionalTag || '',
            char?.additionalTag || ''
        ].filter(p => p);

        return parts.join(', ');
    }

    function buildActionPrompt(actionIdx, composition = null) {
        const charIdx = document.getElementById('character').value;
        const placeIdx = document.getElementById('place').value;
        const modelId = getFirstModel();
        const model = models[modelId] || {};
        const char = charIdx !== '' ? characters[charIdx] : null;
        const place = placeIdx !== '' ? places[placeIdx] : null;
        const action = actions[actionIdx] || {};
        const comp = composition || selectBestComposition(action.compositions);

        const parts = [
            model.qualityPositive || '',
            char?.tag || '',
            place?.tag || '',
            action.prompt || '',
            comp?.tag || comp?.name || '',
            place?.additionalTag || '',
            char?.additionalTag || ''
        ].filter(p => p);

        return parts.join(', ');
    }

    async function generateSceneImage() {
        const apiKey = document.getElementById('apiKey').value.trim();
        if (!apiKey) {
            alert('Runware API Keyを設定してください');
            toggleSettings();
            return;
        }

        const modelId = getFirstModel();
        if (!modelId) {
            alert('GASからデータを読み込んでください');
            return;
        }

        const charIdx = document.getElementById('character').value;
        const placeIdx = document.getElementById('place').value;
        if (charIdx === '' && placeIdx === '') {
            alert('キャラクターまたは場所を選択してください');
            return;
        }

        const btn = document.getElementById('scene-btn');
        btn.disabled = true;
        btn.textContent = '生成中...';

        const sceneDiv = document.getElementById('scene-image');
        sceneDiv.innerHTML = '<div class="scene-placeholder">シーン画像を生成中...</div>';

        try {
            const model = models[modelId];
            const prompt = buildScenePrompt();
            const result = await generateImage(apiKey, modelId, prompt, {
                negativePrompt: model?.qualityNegative || '',
                steps: model?.steps || 20,
                cfgScale: model?.cfgScale || 7,
                scheduler: model?.scheduler || 'Default',
                width: 1024,
                height: 1024
            });

            currentSceneUrl = result.imageURL;
            const dialogueDiv = document.getElementById('scene-dialogue');
            const dialogueHtml = dialogueDiv ? dialogueDiv.outerHTML : '<div class="scene-dialogue" id="scene-dialogue"></div>';
            sceneDiv.innerHTML = `<img src="${result.imageURL}" alt="Scene" onclick="window.open('${result.imageURL}', '_blank')">${dialogueHtml}`;
            addMessage('system', 'シーン画像が更新されました');
        } catch (error) {
            console.error(error);
            const dialogueDiv = document.getElementById('scene-dialogue');
            const dialogueHtml = dialogueDiv ? dialogueDiv.outerHTML : '<div class="scene-dialogue" id="scene-dialogue"></div>';
            sceneDiv.innerHTML = `<div class="scene-placeholder" style="color:#e74c3c;">エラー: ${error.message}</div>${dialogueHtml}`;
        } finally {
            btn.disabled = false;
            btn.textContent = 'シーン生成';
        }
    }

    async function executeAction() {
        const apiKey = document.getElementById('apiKey').value.trim();
        if (!apiKey) {
            alert('Runware API Keyを設定してください');
            toggleSettings();
            return;
        }

        const modelId = getFirstModel();
        if (!modelId) {
            alert('GASからデータを読み込んでください');
            return;
        }

        const actionIdx = document.getElementById('action').value;
        if (actionIdx === '') {
            alert('アクションを選択してください');
            return;
        }

        const action = actions[actionIdx];
        const btn = document.getElementById('action-btn');
        btn.disabled = true;
        btn.textContent = '実行中...';

        const sceneDiv = document.getElementById('scene-image');
        const thumbsDiv = document.getElementById('scene-thumbnails');

        // ローディング表示（画像は消さない）
        let loadingDiv = document.getElementById('scene-loading');
        if (!loadingDiv) {
            loadingDiv = document.createElement('div');
            loadingDiv.id = 'scene-loading';
            loadingDiv.className = 'scene-loading';
            sceneDiv.parentElement.appendChild(loadingDiv);
        }
        loadingDiv.textContent = `「${action.name}」を実行中...`;
        loadingDiv.style.display = 'block';

        try {
            const model = models[modelId];

            // 優先度の高い構図を3つ選択
            const topCompositions = selectTopCompositions(action.compositions, 3);
            if (topCompositions.length === 0) {
                topCompositions.push({ name: 'front view', tag: 'front view' });
            }

            // 各構図で画像生成（並列）
            const imagePromises = topCompositions.map(comp => {
                const prompt = buildActionPrompt(actionIdx, comp);
                return generateImage(apiKey, modelId, prompt, {
                    negativePrompt: model?.qualityNegative || '',
                    steps: model?.steps || 20,
                    cfgScale: model?.cfgScale || 7,
                    scheduler: model?.scheduler || 'Default',
                    width: 1024,
                    height: 1024
                }).then(result => ({
                    url: result.imageURL,
                    composition: comp.name,
                    quality: comp.quality
                })).catch(e => {
                    console.error(`Image gen failed for ${comp.name}:`, e);
                    return null;
                });
            });

            // LLMリクエストも並列（画像枚数分のパターンを要求）
            const reactionPromise = getCharacterReaction(action, topCompositions.length);

            // 全て完了を待つ
            const results = await Promise.all([...imagePromises, reactionPromise]);
            const imageResults = results.slice(0, -1).filter(r => r !== null);
            const patterns = results[results.length - 1] || [];

            // ローディング非表示
            loadingDiv.style.display = 'none';

            if (imageResults.length > 0) {
                // 各画像にセリフパターンを紐付け
                const imagesWithDialogue = imageResults.map((img, i) => ({
                    ...img,
                    narration: patterns[i]?.narration || '',
                    dialogue: patterns[i]?.dialogue || ''
                }));

                // 新しい画像を先頭に追加
                generatedImages = [...imagesWithDialogue, ...generatedImages];
                displayGeneratedImages(0);

                // 最初のパターンをチャット欄に表示
                displayReactionPatterns(patterns);

                addMessage('system', `「${action.name}」を実行した！（${imageResults.length}枚生成、計${generatedImages.length}枚）`);
            } else {
                addMessage('system', '画像生成に失敗しました');
            }
        } catch (error) {
            console.error(error);
            const loadingDiv = document.getElementById('scene-loading');
            if (loadingDiv) loadingDiv.style.display = 'none';
            addMessage('system', `エラー: ${error.message}`);
        } finally {
            btn.disabled = false;
            btn.textContent = 'アクション実行';
        }
    }

    function displayGeneratedImages(activeIndex) {
        const sceneDiv = document.getElementById('scene-image');
        const thumbsDiv = document.getElementById('scene-thumbnails');

        if (generatedImages.length === 0) return;

        currentImageIndex = activeIndex;
        const activeImg = generatedImages[activeIndex];
        currentSceneUrl = activeImg.url;

        // 画像を更新（dialogue divも再作成）
        sceneDiv.innerHTML = `<img src="${activeImg.url}" alt="${activeImg.composition}" onclick="window.open('${activeImg.url}', '_blank')"><div class="scene-dialogue" id="scene-dialogue"></div>`;

        // この画像に紐付くセリフを表示
        if (activeImg.dialogue) {
            showSceneDialogue(activeImg.dialogue);
        } else {
            const dialogueDiv = document.getElementById('scene-dialogue');
            if (dialogueDiv) dialogueDiv.style.display = 'none';
        }

        // サムネイル表示
        if (generatedImages.length > 1) {
            thumbsDiv.innerHTML = generatedImages.map((img, i) =>
                `<img src="${img.url}" class="scene-thumb ${i === activeIndex ? 'active' : ''}"
                      onclick="displayGeneratedImages(${i})"
                      title="${img.composition} [${img.quality || ''}]">`
            ).join('');
            thumbsDiv.style.display = 'flex';
        } else {
            thumbsDiv.style.display = 'none';
        }
    }

    // キーボード操作
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        if (e.key === 'ArrowLeft' && generatedImages.length > 1) {
            const newIndex = (currentImageIndex - 1 + generatedImages.length) % generatedImages.length;
            displayGeneratedImages(newIndex);
        } else if (e.key === 'ArrowRight' && generatedImages.length > 1) {
            const newIndex = (currentImageIndex + 1) % generatedImages.length;
            displayGeneratedImages(newIndex);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            const actionSelect = document.getElementById('action');
            const currentIdx = parseInt(actionSelect.value);
            if (currentIdx < actions.length - 1) {
                actionSelect.value = currentIdx + 1;
                executeAction();
            } else if (actions.length > 0) {
                actionSelect.value = 0;
                executeAction();
            }
        }
    });

    async function getCharacterReaction(action, patternCount = 1) {
        const charIdx = document.getElementById('character').value;
        if (charIdx === '') return [];

        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) return [];

        const char = characters[charIdx];
        const placeIdx = document.getElementById('place').value;
        const place = placeIdx !== '' ? places[placeIdx] : null;

        try {
            const systemPrompt = buildCharacterSystemPrompt(char, true, patternCount);
            const actionContext = `[アクション: ${action.name}]\n[状況: ${action.prompt || action.name}]`;

            const messages = [
                { role: 'system', content: systemPrompt },
                ...chatHistory.map(m => ({ role: m.role, content: m.content })),
                { role: 'user', content: actionContext }
            ];

            const chatModel = document.getElementById('chatModel').value || 'x-ai/grok-4.1-fast';
            console.log('[Reaction] Model:', chatModel);
            console.log('[Reaction] Messages:', JSON.stringify(messages, null, 2));

            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${chatApiKey}`
                },
                body: JSON.stringify({
                    model: chatModel,
                    messages: messages,
                    max_tokens: 300 * patternCount,
                    stream: false
                })
            });

            if (!response.ok) {
                const error = await response.json();
                console.error('Reaction API error:', JSON.stringify(error, null, 2));
                addMessage('system', `リアクションエラー: ${JSON.stringify(error.error)}`);
                return [];
            }

            const data = await response.json();
            if (data.choices && data.choices[0]) {
                const reply = data.choices[0].message.content;
                chatHistory.push({ role: 'user', content: actionContext });

                // 複数パターンをパースして返す
                return parseMultiplePatterns(reply, patternCount);
            }
            return [];
        } catch (error) {
            console.error('Reaction error:', error);
            addMessage('system', `リアクション通信エラー: ${error.message}`);
            return [];
        }
    }

    function parseMultiplePatterns(reply, expectedCount) {
        const patterns = [];

        // [パターンN]で分割
        const patternRegex = /\[パターン(\d+)\]/g;
        const parts = reply.split(patternRegex);

        // parts[0]は最初の[パターン1]より前のテキスト（空か無視）
        // parts[1]は"1", parts[2]はパターン1の内容, parts[3]は"2", parts[4]はパターン2の内容...
        for (let i = 1; i < parts.length; i += 2) {
            const content = parts[i + 1] || '';
            const narrationMatch = content.match(/\[地の文\]\s*([\s\S]*?)(?=\[セリフ\]|$)/);
            const dialogueMatch = content.match(/\[セリフ\]\s*([\s\S]*?)(?=\[パターン|$)/);

            patterns.push({
                narration: narrationMatch ? narrationMatch[1].trim() : '',
                dialogue: dialogueMatch ? dialogueMatch[1].trim() : ''
            });
        }

        // パターンが見つからない場合、旧形式でパース
        if (patterns.length === 0) {
            const narrationMatch = reply.match(/\[地の文\]\s*([\s\S]*?)(?=\[セリフ\]|$)/);
            const dialogueMatch = reply.match(/\[セリフ\]\s*([\s\S]*?)$/);
            patterns.push({
                narration: narrationMatch ? narrationMatch[1].trim() : '',
                dialogue: dialogueMatch ? dialogueMatch[1].trim() : reply.trim()
            });
        }

        // 足りない分は最後のパターンで埋める
        while (patterns.length < expectedCount) {
            patterns.push(patterns[patterns.length - 1] || { narration: '', dialogue: '' });
        }

        return patterns;
    }

    function displayReactionPatterns(patterns) {
        // 最初のパターンをチャット欄に表示
        if (patterns.length > 0 && patterns[0]) {
            if (patterns[0].narration) {
                addMessage('narration', patterns[0].narration);
            }
            if (patterns[0].dialogue) {
                addMessage('assistant', patterns[0].dialogue);
            }
        }
    }

    function showSceneDialogue(text) {
        const charIdx = document.getElementById('character').value;
        const char = charIdx !== '' ? characters[charIdx] : null;
        const dialogueDiv = document.getElementById('scene-dialogue');

        if (char) {
            dialogueDiv.innerHTML = `<span class="char-name">${char.name}</span>${text}`;
        } else {
            dialogueDiv.textContent = text;
        }

        // チャット欄と同じフォントサイズを適用
        const messagesDiv = document.getElementById('chat-messages');
        dialogueDiv.classList.remove('font-small', 'font-large');
        if (messagesDiv.classList.contains('font-small')) {
            dialogueDiv.classList.add('font-small');
        } else if (messagesDiv.classList.contains('font-large')) {
            dialogueDiv.classList.add('font-large');
        }

        dialogueDiv.style.display = 'block';
    }

    // チャット機能
    function addMessage(role, content) {
        const messagesDiv = document.getElementById('chat-messages');
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${role}`;
        msgDiv.textContent = content;
        messagesDiv.appendChild(msgDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        // APIに送信可能なroleのみ履歴に追加
        if (role === 'user' || role === 'assistant') {
            chatHistory.push({ role, content });
        }
    }

    function clearChat() {
        document.getElementById('chat-messages').innerHTML = '';
        chatHistory = [];
    }

    async function sendMessage() {
        const input = document.getElementById('chat-input');
        const message = input.value.trim();
        if (!message) return;

        const charIdx = document.getElementById('character').value;
        if (charIdx === '') {
            alert('キャラクターを選択してください');
            return;
        }

        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) {
            alert('OpenRouter API Keyを設定してください');
            toggleSettings();
            return;
        }

        const char = characters[charIdx];
        input.value = '';
        addMessage('user', message);

        try {
            const systemPrompt = buildCharacterSystemPrompt(char);
            const messages = [
                { role: 'system', content: systemPrompt },
                ...chatHistory.map(m => ({ role: m.role, content: m.content }))
            ];

            const chatModel = document.getElementById('chatModel').value || 'x-ai/grok-4.1-fast';
            console.log('[Chat] Model:', chatModel);
            console.log('[Chat] Messages:', JSON.stringify(messages, null, 2));

            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${chatApiKey}`
                },
                body: JSON.stringify({
                    model: chatModel,
                    messages: messages,
                    max_tokens: 500,
                    stream: false
                })
            });

            if (!response.ok) {
                const error = await response.json();
                addMessage('system', `エラー: ${error.error?.message || response.statusText}`);
                return;
            }

            const data = await response.json();
            if (data.choices && data.choices[0]) {
                const reply = data.choices[0].message.content;
                addMessage('assistant', reply);
            }
        } catch (error) {
            console.error(error);
            addMessage('system', `通信エラー: ${error.message}`);
        }
    }

    function buildCharacterSystemPrompt(char, isAction = false, patternCount = 1) {
        const placeIdx = document.getElementById('place').value;
        const place = placeIdx !== '' ? places[placeIdx] : null;

        let prompt = `あなたは「${char.name}」というキャラクターです。`;
        if (char.series) prompt += `作品「${char.series}」に登場します。`;
        if (char.profile) prompt += `\n\nプロフィール: ${char.profile}`;
        if (place) prompt += `\n\n現在の場所: ${place.name}`;

        if (isAction) {
            prompt += `\n\n【出力形式】
${patternCount}パターンの反応を生成してください。各パターンは以下の形式で出力：

[パターン1]
[地の文]
官能小説のような生々しい描写。身体の状態、性的な部位の様子、肌の感触、体温、濡れ具合、締め付けなどを具体的かつ官能的に表現。

[セリフ]
キャラクターの声、吐息、言葉。「」で囲む。

[パターン2]
[地の文]
（別の描写バリエーション）

[セリフ]
（別のセリフバリエーション）

...以下同様に${patternCount}パターンまで

必ず[パターンN]、[地の文]、[セリフ]のタグを使用してください。各パターンは異なる表現・セリフにしてください。`;
        } else {
            prompt += '\n\nキャラクターになりきって、短く自然な会話で応答してください。';
        }
        return prompt;
    }
</script>

</body>
</html>
