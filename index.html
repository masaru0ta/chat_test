<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure Game</title>
    <link rel="stylesheet" href="css/common.css">
    <style>
        body { padding: 0; }

        .game-container {
            display: grid;
            grid-template-columns: 1fr 5px 400px;
            grid-template-rows: 1fr auto;
            height: 100vh;
            gap: 0;
        }

        .resize-handle {
            width: 5px;
            background: #333;
            cursor: col-resize;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: #4a9eff;
        }

        /* シーンエリア */
        .scene-area {
            background: #111;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        .scene-image {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 20px;
            position: relative;
        }

        .scene-image:has(.scene-narration) {
            justify-content: flex-start;
            align-items: flex-start;
            overflow-y: auto;
        }

        .scene-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            cursor: pointer;
        }

        .scene-placeholder {
            color: #666;
            font-size: 1.2rem;
            text-align: center;
        }

        .scene-narration {
            max-width: 800px;
            padding: 30px 40px;
            color: #fff;
            font-size: 1.3rem;
            font-weight: 100;
            line-height: 2;
            text-align: left;
            position: relative;
            z-index: 2;
        }

        .scene-narration p {
            margin: 0;
        }

        .scene-bg-image {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-size: cover;
            background-position: center;
            opacity: 0.3;
            z-index: 1;
        }

        .scene-loading {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #4a9eff;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 0.85rem;
            z-index: 10;
        }

        .scene-dialogue {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 15px 20px;
            font-family: "M PLUS 1 Code", sans-serif;
            font-weight: 200;
            font-size: 1.35rem;
            line-height: 1.8;
            z-index: 5;
            display: none;
        }

        .scene-dialogue.font-large {
            font-size: 1.6rem;
            line-height: 1.9;
        }

        .scene-dialogue.font-small {
            font-size: 1.1rem;
            line-height: 1.7;
        }

        .scene-dialogue .char-name {
            color: #4a9eff;
            font-weight: bold;
            margin-right: 8px;
        }

        .scene-thumbnails {
            display: flex;
            gap: 8px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            overflow-x: auto;
            flex-shrink: 0;
        }

        .scene-thumb {
            width: 60px;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            opacity: 0.6;
            transition: all 0.2s;
        }

        .scene-thumb:hover {
            opacity: 0.9;
        }

        .scene-thumb.active {
            border-color: #4a9eff;
            opacity: 1;
        }

        .scene-thumb.narration-thumb {
            background: linear-gradient(135deg, #9b59b6 0%, #6c3483 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: #fff;
            opacity: 0.8;
            text-align: center;
            padding: 4px;
            line-height: 1.2;
            word-break: break-all;
        }

        .scene-thumb.narration-thumb:hover {
            opacity: 1;
        }

        .scene-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .scene-info .char-name {
            color: #4a9eff;
            font-weight: bold;
        }

        .scene-info .place-name {
            color: #27ae60;
        }

        /* チャットエリア */
        .chat-area {
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #333;
            overflow: hidden;
            min-height: 0;
        }

        .chat-header {
            padding: 15px;
            background: #222;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-header h2 {
            margin: 0;
            color: #4a9eff;
            font-size: 1rem;
            flex: 1;
        }

        .font-size-btns {
            display: flex;
            gap: 4px;
        }

        .font-size-btns button {
            background: #444;
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .font-size-btns button:hover {
            background: #555;
        }

        .font-size-btns button.active {
            background: #4a9eff;
        }

        /* 中（デフォルト）: 1.35rem */
        .chat-messages .message {
            font-size: 1.35rem;
            line-height: 1.8;
        }

        .chat-messages .message.narration {
            font-size: 1.25rem;
        }

        /* 大: 1.6rem */
        .chat-messages.font-large .message {
            font-size: 1.6rem;
            line-height: 1.9;
        }

        .chat-messages.font-large .message.narration {
            font-size: 1.5rem;
        }

        /* 小: 1.1rem */
        .chat-messages.font-small .message {
            font-size: 1.1rem;
            line-height: 1.7;
        }

        .chat-messages.font-small .message.narration {
            font-size: 1.05rem;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }

        .message {
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .message.user {
            background: #4a9eff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .message.assistant {
            background: #333;
            color: #e0e0e0;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .message.system {
            background: #2a2a2a;
            color: #888;
            align-self: center;
            font-size: 0.85rem;
            font-style: italic;
        }

        .message.narration {
            background: transparent;
            color: #c9a0dc;
            align-self: stretch;
            max-width: 100%;
            font-size: 0.9rem;
            line-height: 1.8;
            padding: 15px;
            border-left: 3px solid #9b59b6;
        }

        .chat-input-area {
            padding: 15px;
            background: #222;
            border-top: 1px solid #333;
            display: flex;
            gap: 10px;
        }

        .chat-input-area input {
            flex: 1;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 20px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.95rem;
        }

        .chat-input-area input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .chat-input-area button {
            padding: 12px 20px;
            border-radius: 20px;
        }

        /* コントロールバー */
        .control-bar {
            grid-column: 1 / 4;
            background: #1a1a1a;
            border-top: 1px solid #333;
            padding: 15px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            color: #888;
            font-size: 0.85rem;
            white-space: nowrap;
        }

        .control-group select {
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.9rem;
            min-width: 150px;
        }

        .control-actions {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        .btn-toggle {
            background: #555;
            min-width: 70px;
        }

        .btn-toggle.active {
            background: #27ae60;
        }

        /* 設定パネル */
        .settings-toggle {
            position: fixed;
            top: 10px;
            right: 420px;
            background: #333;
            border: none;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 100;
        }

        .settings-toggle:hover {
            background: #444;
        }

        .settings-panel {
            position: fixed;
            top: 50px;
            right: 420px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            width: 350px;
            display: none;
            z-index: 100;
        }

        .settings-panel.active {
            display: block;
        }

        .settings-panel h3 {
            margin: 0 0 15px 0;
            color: #4a9eff;
            font-size: 1rem;
        }

        .settings-panel .form-group {
            margin-bottom: 12px;
        }

        .settings-panel .form-group label {
            display: block;
            color: #888;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }

        .settings-panel .form-group input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.85rem;
        }

        .settings-panel .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #settings-status {
            margin-top: 10px;
            font-size: 0.8rem;
        }

        /* レスポンシブ */
        @media (max-width: 900px) {
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: 50vh 1fr auto;
            }
            .chat-area {
                border-left: none;
                border-top: 1px solid #333;
            }
            .settings-toggle {
                right: 10px;
            }
            .settings-panel {
                right: 10px;
                width: calc(100% - 40px);
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- シーンエリア -->
    <div class="scene-area">
        <div class="scene-info">
            <span class="char-name" id="current-char">キャラクター未選択</span>
            <span style="color: #666;"> @ </span>
            <span class="place-name" id="current-place">場所未選択</span>
        </div>
        <div class="scene-thumbnails" id="scene-thumbnails" style="display: none;"></div>
        <div class="scene-image" id="scene-image">
            <div class="scene-placeholder">
                キャラクターと場所を選択してください<br>
                <small style="color: #555;">設定ボタンからGASデータを読み込んでください</small>
            </div>
            <div class="scene-dialogue" id="scene-dialogue"></div>
        </div>
    </div>

    <!-- リサイズハンドル -->
    <div class="resize-handle" id="resize-handle"></div>

    <!-- チャットエリア -->
    <div class="chat-area" id="chat-area">
        <div class="chat-header">
            <h2 id="chat-title">チャット</h2>
            <div class="font-size-btns">
                <button onclick="setFontSize('small')" id="font-small">小</button>
                <button onclick="setFontSize('normal')" id="font-normal" class="active">中</button>
                <button onclick="setFontSize('large')" id="font-large">大</button>
            </div>
            <button class="btn btn-small" onclick="clearChat()" style="background:#555;">クリア</button>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="message system">キャラクターを選択するとチャットできます</div>
        </div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="メッセージを入力..." onkeydown="if(event.key==='Enter')sendMessage()">
            <button class="btn btn-primary" onclick="sendMessage()">送信</button>
        </div>
    </div>

    <!-- コントロールバー -->
    <div class="control-bar">
        <div class="control-group">
            <label>キャラクター:</label>
            <select id="character" onchange="onCharacterChange()">
                <option value="">-- 選択 --</option>
            </select>
        </div>
        <div class="control-group">
            <label>場所:</label>
            <select id="place" onchange="onPlaceChange()">
                <option value="">-- 選択 --</option>
            </select>
        </div>
        <div class="control-group">
            <label>アクション:</label>
            <select id="action" onchange="onActionChange()">
                <option value="">-- 選択 --</option>
            </select>
        </div>
        <div class="control-actions">
            <button class="btn btn-toggle active" onclick="toggleImageGen(this)" id="image-toggle">画像ON</button>
            <button class="btn btn-generate" onclick="executeAction()" id="action-btn">アクション実行</button>
            <button class="btn btn-primary" onclick="generateSceneImage()" id="scene-btn">シーン生成</button>
        </div>
    </div>
</div>

<!-- 設定パネル -->
<button class="settings-toggle" onclick="toggleSettings()">設定</button>
<div class="settings-panel" id="settings-panel">
    <h3>設定</h3>
    <div class="form-group">
        <label>GAS URL:</label>
        <input type="text" id="gasUrl" placeholder="https://script.google.com/macros/s/xxx/exec">
    </div>
    <div class="form-group">
        <label>Runware API Key:</label>
        <input type="password" id="apiKey" placeholder="画像生成用">
    </div>
    <div class="form-group">
        <label>OpenRouter API Key:</label>
        <input type="password" id="chatApiKey" placeholder="チャット用">
    </div>
    <div class="form-group">
        <label>チャットモデル:</label>
        <select id="chatModel">
            <option value="x-ai/grok-4.1-fast">Grok 4.1 Fast</option>
            <option value="google/gemini-2.0-flash-001">Gemini 2.0 Flash</option>
            <option value="anthropic/claude-3.5-haiku">Claude 3.5 Haiku</option>
            <option value="openai/gpt-4o-mini">GPT-4o Mini</option>
        </select>
    </div>
    <div class="btn-row">
        <button class="btn btn-primary" onclick="loadAllFromGas()">GAS読み込み</button>
        <button class="btn btn-save" onclick="doSaveSettings()">設定保存</button>
    </div>
    <div id="settings-status"></div>
</div>

<script src="js/constants.js"></script>
<script src="js/gas-api.js"></script>
<script src="js/prompt-utils.js"></script>
<script src="js/runware-api.js"></script>
<script src="js/storage.js"></script>
<script src="js/data-parser.js"></script>
<script src="js/ui-utils.js"></script>
<script>
    // ストレージキー
    const GAME_DATA_KEY = 'adventure_game_data';
    const CHAT_API_KEY = 'openrouter_api_key';
    const CHAT_MODEL_KEY = 'openrouter_model';
    const LAST_SELECTION_KEY = 'adventure_last_selection';

    // データストア
    let models = {};
    let characters = [];
    let places = [];
    let actions = [];
    let relationships = [];
    let costumes = [];
    let chatHistory = [];
    let currentSceneUrl = '';
    let generatedImages = [];
    let currentImageIndex = 0;
    let currentGroupId = 0;  // アクション実行ごとのグループID

    // 初期化
    document.addEventListener('DOMContentLoaded', () => {
        const settings = loadSettings(STORAGE_KEYS.GAS_URL, STORAGE_KEYS.API_KEY);
        if (settings.gasUrl) document.getElementById('gasUrl').value = settings.gasUrl;
        if (settings.apiKey) document.getElementById('apiKey').value = settings.apiKey;

        const chatApiKey = localStorage.getItem(CHAT_API_KEY);
        if (chatApiKey) document.getElementById('chatApiKey').value = chatApiKey;

        const chatModel = localStorage.getItem(CHAT_MODEL_KEY);
        if (chatModel) document.getElementById('chatModel').value = chatModel;

        // 保存された文字サイズを復元
        const savedFontSize = localStorage.getItem('chat_font_size') || 'normal';
        setFontSize(savedFontSize);

        // 保存されたチャット幅を復元
        const savedChatWidth = localStorage.getItem('chat_width');
        if (savedChatWidth) {
            document.querySelector('.game-container').style.gridTemplateColumns = `1fr 5px ${savedChatWidth}px`;
        }

        loadCachedData();
        restoreLastSelection();
        initResize();
    });

    // 選択状態の保存
    let isRestoring = false;  // 復元中フラグ
    function saveLastSelection() {
        if (isRestoring) return;  // 復元中は保存しない
        const selection = {
            character: document.getElementById('character').value,
            place: document.getElementById('place').value,
            action: document.getElementById('action').value
        };
        localStorage.setItem(LAST_SELECTION_KEY, JSON.stringify(selection));
    }

    // 選択状態の復元
    function restoreLastSelection() {
        try {
            const saved = localStorage.getItem(LAST_SELECTION_KEY);
            if (!saved) return;

            isRestoring = true;  // 復元開始

            const selection = JSON.parse(saved);
            const charSelect = document.getElementById('character');
            const placeSelect = document.getElementById('place');
            const actionSelect = document.getElementById('action');

            // 保存された値が現在の選択肢に存在するか確認して復元
            if (selection.character && charSelect.querySelector(`option[value="${selection.character}"]`)) {
                charSelect.value = selection.character;
                onCharacterChange();
            }
            if (selection.place && placeSelect.querySelector(`option[value="${selection.place}"]`)) {
                placeSelect.value = selection.place;
                onPlaceChange();
            }
            if (selection.action && actionSelect.querySelector(`option[value="${selection.action}"]`)) {
                actionSelect.value = selection.action;
            }

            isRestoring = false;  // 復元完了
        } catch (e) {
            console.error('Selection restore error:', e);
            isRestoring = false;
        }
    }

    // リサイズ機能
    function initResize() {
        const handle = document.getElementById('resize-handle');
        const container = document.querySelector('.game-container');
        const chatArea = document.getElementById('chat-area');
        let isResizing = false;

        handle.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerRect = container.getBoundingClientRect();
            const newChatWidth = containerRect.right - e.clientX;
            const minWidth = 250;
            const maxWidth = containerRect.width - 300;

            if (newChatWidth >= minWidth && newChatWidth <= maxWidth) {
                container.style.gridTemplateColumns = `1fr 5px ${newChatWidth}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                // 幅を保存
                const cols = container.style.gridTemplateColumns;
                const match = cols.match(/(\d+)px$/);
                if (match) {
                    localStorage.setItem('chat_width', match[1]);
                }
            }
        });
    }

    // 文字サイズ切り替え
    function setFontSize(size) {
        const messagesDiv = document.getElementById('chat-messages');
        const dialogueDiv = document.getElementById('scene-dialogue');
        messagesDiv.classList.remove('font-small', 'font-large');
        if (dialogueDiv) dialogueDiv.classList.remove('font-small', 'font-large');

        document.querySelectorAll('.font-size-btns button').forEach(btn => btn.classList.remove('active'));

        if (size === 'small') {
            messagesDiv.classList.add('font-small');
            if (dialogueDiv) dialogueDiv.classList.add('font-small');
            document.getElementById('font-small').classList.add('active');
        } else if (size === 'large') {
            messagesDiv.classList.add('font-large');
            if (dialogueDiv) dialogueDiv.classList.add('font-large');
            document.getElementById('font-large').classList.add('active');
        } else {
            document.getElementById('font-normal').classList.add('active');
        }

        localStorage.setItem('chat_font_size', size);
    }

    function toggleSettings() {
        document.getElementById('settings-panel').classList.toggle('active');
    }

    function doSaveSettings() {
        const gasUrl = document.getElementById('gasUrl').value.trim();
        const apiKey = document.getElementById('apiKey').value.trim();
        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        const chatModel = document.getElementById('chatModel').value;

        saveSettings(STORAGE_KEYS.GAS_URL, STORAGE_KEYS.API_KEY, gasUrl, apiKey);
        if (chatApiKey) localStorage.setItem(CHAT_API_KEY, chatApiKey);
        if (chatModel) localStorage.setItem(CHAT_MODEL_KEY, chatModel);

        showSettingsStatus('設定を保存しました');
    }

    function showSettingsStatus(msg, isError = false) {
        const el = document.getElementById('settings-status');
        el.textContent = msg;
        el.style.color = isError ? '#e74c3c' : '#27ae60';
        setTimeout(() => el.textContent = '', 3000);
    }

    function saveCachedData() {
        localStorage.setItem(GAME_DATA_KEY, JSON.stringify({ models, characters, places, actions, relationships, costumes }));
    }

    function loadCachedData() {
        try {
            const cached = localStorage.getItem(GAME_DATA_KEY);
            if (cached) {
                const data = JSON.parse(cached);
                models = data.models || {};
                characters = data.characters || [];
                places = data.places || [];
                actions = data.actions || [];
                relationships = data.relationships || [];
                costumes = data.costumes || [];
                updateAllSelects();
            }
        } catch (e) {
            console.error('Cache load error:', e);
        }
    }

    async function loadAllFromGas() {
        const baseUrl = document.getElementById('gasUrl').value.trim();
        if (!baseUrl) {
            alert('GAS URLを入力してください');
            return;
        }

        doSaveSettings();
        showSettingsStatus('読み込み中...', false);

        try {
            const [modelData, characterData, placeData, actionData, relationshipData, costumeData] = await Promise.all([
                fetchGasData(baseUrl, 'model'),
                fetchGasData(baseUrl, 'character'),
                fetchGasData(baseUrl, 'place'),
                fetchGasData(baseUrl, 'action'),
                fetchGasData(baseUrl, 'relationship'),
                fetchGasData(baseUrl, 'costume')
            ]);

            models = parseModels(modelData);
            characters = parseCharacters(characterData);
            places = parsePlaces(placeData);
            actions = parseActionsWithCompositions(actionData);
            relationships = parseRelationships(relationshipData);
            costumes = parseCostumes(costumeData);

            saveCachedData();
            updateAllSelects();
            showSettingsStatus(`読込完了: キャラ${characters.length}, 場所${places.length}, アクション${actions.length}`);
        } catch (error) {
            console.error(error);
            showSettingsStatus('エラー: ' + error.message, true);
        }
    }

    function updateAllSelects() {
        // キャラクター
        const charSelect = document.getElementById('character');
        charSelect.innerHTML = '<option value="">-- 選択 --</option>';
        characters.forEach((char, i) => {
            charSelect.innerHTML += `<option value="${i}">${char.name}${char.series ? ' (' + char.series + ')' : ''}</option>`;
        });

        // 場所
        const placeSelect = document.getElementById('place');
        placeSelect.innerHTML = '<option value="">-- 選択 --</option>';
        places.forEach((place, i) => {
            placeSelect.innerHTML += `<option value="${i}">${place.name}</option>`;
        });

        // アクション
        const actionSelect = document.getElementById('action');
        actionSelect.innerHTML = '<option value="">-- 選択 --</option>';
        actions.forEach((action, i) => {
            actionSelect.innerHTML += `<option value="${i}">${action.name}</option>`;
        });
    }

    function onCharacterChange() {
        const idx = document.getElementById('character').value;
        const char = idx !== '' ? characters[idx] : null;

        document.getElementById('current-char').textContent = char ? char.name : 'キャラクター未選択';
        document.getElementById('chat-title').textContent = char ? `${char.name}とチャット` : 'チャット';

        if (char) {
            clearChat();
            addMessage('system', `${char.name}が現れた！`);
            if (char.profile) {
                addMessage('system', `[${char.profile}]`);
            }
        }
        saveLastSelection();
    }

    // 選択中のキャラクターを取得
    function getSelectedCharacter() {
        const idx = document.getElementById('character').value;
        return idx !== '' ? (characters[idx] || null) : null;
    }

    function onPlaceChange() {
        const idx = document.getElementById('place').value;
        const place = idx !== '' ? places[idx] : null;
        document.getElementById('current-place').textContent = place ? place.name : '場所未選択';

        if (place) {
            addMessage('system', `場所が「${place.name}」に変わった`);
        }
        saveLastSelection();
    }

    function onActionChange() {
        saveLastSelection();
    }

    // 画像生成ON/OFF切り替え
    let imageGenEnabled = true;
    function toggleImageGen(btn) {
        imageGenEnabled = !imageGenEnabled;
        btn.textContent = imageGenEnabled ? '画像ON' : '画像OFF';
        btn.classList.toggle('active', imageGenEnabled);
    }

    function getFirstModel() {
        return Object.keys(models)[0] || null;
    }

    // selectBestComposition は js/prompt-utils.js で定義

    function selectTopCompositions(compositions, count = 3) {
        if (!compositions || compositions.length === 0) return [];

        // 優先度でソート
        const priority = { 'BEST': 0, 'best': 0, 'Good': 1, 'good': 1 };
        const sorted = [...compositions].sort((a, b) => {
            const pa = priority[a.quality] ?? 2;
            const pb = priority[b.quality] ?? 2;
            return pa - pb;
        });

        return sorted.slice(0, count);
    }

    function buildScenePrompt() {
        const charIdx = document.getElementById('character').value;
        const placeIdx = document.getElementById('place').value;
        const modelId = getFirstModel();
        const model = models[modelId] || {};
        const char = charIdx !== '' ? characters[charIdx] : null;
        const place = placeIdx !== '' ? places[placeIdx] : null;
        const action = actions[0] || {};
        const comp = selectBestComposition(action.compositions);

        const parts = [
            model.qualityPositive || '',
            char?.tag || '',
            place?.tag || '',
            action.prompt || '',
            comp?.tag || comp?.name || 'front view',
            place?.additionalTag || '',
            char?.additionalTag || ''
        ].filter(p => p);

        return parts.join(', ');
    }

    function buildActionPrompt(actionIdx, composition = null) {
        const charIdx = document.getElementById('character').value;
        const placeIdx = document.getElementById('place').value;
        const modelId = getFirstModel();
        const model = models[modelId] || {};
        const char = charIdx !== '' ? characters[charIdx] : null;
        const place = placeIdx !== '' ? places[placeIdx] : null;
        const action = actions[actionIdx] || {};
        const comp = composition || selectBestComposition(action.compositions);

        const parts = [
            model.qualityPositive || '',
            char?.tag || '',
            place?.tag || '',
            action.prompt || '',
            comp?.tag || comp?.name || '',
            place?.additionalTag || '',
            char?.additionalTag || ''
        ].filter(p => p);

        return parts.join(', ');
    }

    async function generateSceneImage() {
        const apiKey = document.getElementById('apiKey').value.trim();
        if (!apiKey) {
            alert('Runware API Keyを設定してください');
            toggleSettings();
            return;
        }

        const modelId = getFirstModel();
        if (!modelId) {
            alert('GASからデータを読み込んでください');
            return;
        }

        const charIdx = document.getElementById('character').value;
        const placeIdx = document.getElementById('place').value;
        if (charIdx === '' && placeIdx === '') {
            alert('キャラクターまたは場所を選択してください');
            return;
        }

        const btn = document.getElementById('scene-btn');
        btn.disabled = true;
        btn.textContent = '生成中...';

        const sceneDiv = document.getElementById('scene-image');
        sceneDiv.innerHTML = '<div class="scene-placeholder">シーン画像を生成中...</div>';

        try {
            const model = models[modelId];
            const prompt = buildScenePrompt();
            const result = await generateImage(apiKey, modelId, prompt, {
                negativePrompt: model?.qualityNegative || '',
                steps: model?.steps || 20,
                cfgScale: model?.cfgScale || 7,
                scheduler: model?.scheduler || 'Default',
                width: 1024,
                height: 1024,
                character: getSelectedCharacter()
            });

            currentSceneUrl = result.imageURL;
            const dialogueDiv = document.getElementById('scene-dialogue');
            const dialogueHtml = dialogueDiv ? dialogueDiv.outerHTML : '<div class="scene-dialogue" id="scene-dialogue"></div>';
            sceneDiv.innerHTML = `<img src="${result.imageURL}" alt="Scene" onclick="window.open('${result.imageURL}', '_blank')">${dialogueHtml}`;
            addMessage('system', 'シーン画像が更新されました');
        } catch (error) {
            console.error(error);
            const dialogueDiv = document.getElementById('scene-dialogue');
            const dialogueHtml = dialogueDiv ? dialogueDiv.outerHTML : '<div class="scene-dialogue" id="scene-dialogue"></div>';
            sceneDiv.innerHTML = `<div class="scene-placeholder" style="color:#e74c3c;">エラー: ${error.message}</div>${dialogueHtml}`;
        } finally {
            btn.disabled = false;
            btn.textContent = 'シーン生成';
        }
    }

    async function executeAction() {
        const apiKey = document.getElementById('apiKey').value.trim();
        const modelId = getFirstModel();

        // 画像ONの場合のみAPIキーとモデルをチェック
        if (imageGenEnabled) {
            if (!apiKey) {
                alert('Runware API Keyを設定してください');
                toggleSettings();
                return;
            }
            if (!modelId) {
                alert('GASからデータを読み込んでください');
                return;
            }
        }

        const actionIdx = document.getElementById('action').value;
        if (actionIdx === '') {
            alert('アクションを選択してください');
            return;
        }

        const action = actions[actionIdx];
        const btn = document.getElementById('action-btn');
        btn.disabled = true;
        btn.textContent = '実行中...';

        const sceneDiv = document.getElementById('scene-image');
        const thumbsDiv = document.getElementById('scene-thumbnails');

        // キャラクター情報を先に取得
        const charIdx = document.getElementById('character').value;
        const char = charIdx !== '' ? characters[charIdx] : null;

        // ローディング表示
        let loadingDiv = document.getElementById('scene-loading');
        if (!loadingDiv) {
            loadingDiv = document.createElement('div');
            loadingDiv.id = 'scene-loading';
            loadingDiv.className = 'scene-loading';
            sceneDiv.parentElement.appendChild(loadingDiv);
        }
        loadingDiv.textContent = `「${action.name}」生成中...`;
        loadingDiv.style.display = 'block';

        try {
            const model = models[modelId];

            // 優先度の高い構図を3つ選択
            const topCompositions = selectTopCompositions(action.compositions, 3);
            if (topCompositions.length === 0) {
                topCompositions.push({ name: 'front view', tag: 'front view' });
            }

            // パターン（LLMの結果）を保持する配列
            let patterns = [];
            let completedImageCount = 0;
            const startTime = Date.now();

            console.log(`[Timing] 全リクエスト開始: ${new Date().toISOString()}`);

            // 新しいグループIDを生成
            currentGroupId++;
            const groupId = currentGroupId;

            // LLMリクエスト（完了したら即座に地の文をサムネイル＆メインエリアに表示）
            const reactionPromise = getCharacterReaction(action, topCompositions.length)
                .then(result => {
                    console.log(`[Timing] LLM完了: ${Date.now() - startTime}ms`);
                    patterns = result;
                    // 地の文をサムネイルに追加（表示は既にストリーミングで完了）
                    if (patterns.length > 0 && patterns[0]?.narration) {
                        const narrationData = {
                            type: 'narration',
                            narration: patterns[0].narration,
                            charName: char?.name || '',
                            actionName: action.name || '',  // アクション名を保存
                            placeImage: getCurrentPlaceImage(),  // 生成時の場所画像を保存
                            groupId: groupId,
                            order: -1  // 画像より前に来るように
                        };
                        addNarrationToThumbnails(narrationData);
                    }
                    if (imageGenEnabled) {
                        loadingDiv.textContent = `画像生成中... (${completedImageCount}/${topCompositions.length})`;
                    }
                    return patterns;
                });

            // 画像生成（ONの場合のみ）
            let imagePromises = [];
            if (imageGenEnabled) {
                imagePromises = topCompositions.map((comp, index) => {
                    const prompt = buildActionPrompt(actionIdx, comp);
                    return generateImage(apiKey, modelId, prompt, {
                        negativePrompt: model?.qualityNegative || '',
                        steps: model?.steps || 20,
                        cfgScale: model?.cfgScale || 7,
                        scheduler: model?.scheduler || 'Default',
                        width: 1024,
                        height: 1024,
                        character: char
                    }).then(result => {
                        completedImageCount++;
                        console.log(`[Timing] 画像${completedImageCount}完了: ${Date.now() - startTime}ms`);
                        loadingDiv.textContent = `画像生成中... (${completedImageCount}/${topCompositions.length})`;

                        const imgData = {
                            type: 'image',
                            url: result.imageURL,
                            composition: comp.name,
                            quality: comp.quality,
                            charName: char?.name || '',
                            // patternsが既に取得済みなら紐付け、未取得なら後で更新
                            narration: patterns[index]?.narration || '',
                            dialogue: patterns[index]?.dialogue || '',
                            groupId: groupId,
                            order: index
                        };

                        // 順次サムネイルに追加
                        addImageToThumbnails(imgData);
                        return imgData;
                    }).catch(e => {
                        completedImageCount++;
                        loadingDiv.textContent = `画像生成中... (${completedImageCount}/${topCompositions.length})`;
                        console.error(`Image gen failed for ${comp.name}:`, e);
                        return null;
                    });
                });
            }

            // 全て（LLM + 画像）の完了を待つ
            const allResults = await Promise.all([reactionPromise, ...imagePromises]);
            patterns = allResults[0] || [];
            const imageResults = allResults.slice(1).filter(r => r !== null);

            // patternsが画像より後に取得された場合、画像データを更新
            imageResults.forEach((img, i) => {
                if (img && patterns[img.order]) {
                    img.narration = patterns[img.order].narration || '';
                    img.dialogue = patterns[img.order].dialogue || '';
                }
            });

            // ローディング非表示
            loadingDiv.style.display = 'none';

            if (imageResults.length > 0) {
                // 画像は既にaddImageToThumbnailsでgeneratedImagesに追加済み
                // patternsデータを画像に紐付け（画像が先に完了した場合の対応）
                generatedImages.forEach(item => {
                    if (item.type === 'image' && patterns[item.order]) {
                        item.narration = patterns[item.order].narration || '';
                        item.dialogue = patterns[item.order].dialogue || '';
                    }
                });

                // サムネイルを更新（表示は切り替えない、ユーザーがクリックで選択）
                rebuildThumbnails(-1);

                // 最初のパターンをチャット欄に表示
                displayReactionPatterns(patterns);

                addMessage('system', `「${action.name}」を実行した！（${imageResults.length}枚生成、計${generatedImages.length}枚）`);
            } else if (!imageGenEnabled) {
                // 画像OFFの場合
                displayReactionPatterns(patterns);
                addMessage('system', `「${action.name}」を実行した！（テキストのみ）`);
            } else {
                addMessage('system', '画像生成に失敗しました');
            }
        } catch (error) {
            console.error(error);
            const loadingDiv = document.getElementById('scene-loading');
            if (loadingDiv) loadingDiv.style.display = 'none';
            addMessage('system', `エラー: ${error.message}`);
        } finally {
            btn.disabled = false;
            btn.textContent = 'アクション実行';
        }
    }

    // 現在選択中の場所画像URLを取得
    function getCurrentPlaceImage() {
        const placeIdx = document.getElementById('place').value;
        const place = placeIdx !== '' ? places[placeIdx] : null;
        return place?.image || '';
    }

    // 地の文を画像エリアに表示
    function showNarrationInSceneArea(narration) {
        const sceneDiv = document.getElementById('scene-image');
        const placeImage = getCurrentPlaceImage();
        const bgHtml = placeImage ? `<div class="scene-bg-image" style="background-image: url('${placeImage}');"></div>` : '';

        sceneDiv.innerHTML = `
            ${bgHtml}
            <div class="scene-narration">
                <p>${narration.replace(/\n/g, '<br>')}</p>
            </div>
            <div class="scene-dialogue" id="scene-dialogue"></div>
        `;
    }

    // 地の文をサムネイルに追加
    function addNarrationToThumbnails(narrationData) {
        const thumbsDiv = document.getElementById('scene-thumbnails');
        thumbsDiv.style.display = 'flex';

        // generatedImagesの先頭に追加（新しいグループが左に来る）
        generatedImages.unshift(narrationData);

        // サムネイルを再構築
        rebuildThumbnails(-1);
    }

    // 画像を順次サムネイルに追加
    function addImageToThumbnails(imgData) {
        const thumbsDiv = document.getElementById('scene-thumbnails');
        thumbsDiv.style.display = 'flex';

        // 同じgroupIdの地の文を探し、その後に挿入
        const narrationIndex = generatedImages.findIndex(
            item => item.type === 'narration' && item.groupId === imgData.groupId
        );

        if (narrationIndex >= 0) {
            // 地の文の後、かつorder順に挿入
            let insertIndex = narrationIndex + 1;
            while (insertIndex < generatedImages.length &&
                   generatedImages[insertIndex].type === 'image' &&
                   generatedImages[insertIndex].groupId === imgData.groupId &&
                   generatedImages[insertIndex].order < imgData.order) {
                insertIndex++;
            }
            generatedImages.splice(insertIndex, 0, imgData);
        } else {
            // 地の文がなければ先頭に追加
            generatedImages.unshift(imgData);
        }

        // サムネイルを再構築
        rebuildThumbnails(-1);
    }

    // サムネイルのアクティブ状態を更新
    function updateThumbnailActive(activeThumb) {
        document.querySelectorAll('.scene-thumb').forEach(t => t.classList.remove('active'));
        if (activeThumb) activeThumb.classList.add('active');
    }

    // 単一画像を表示（generatedImagesに追加前でも使える）
    function showImageWithDialogue(imgData) {
        const sceneDiv = document.getElementById('scene-image');
        sceneDiv.innerHTML = `<img src="${imgData.url}" alt="${imgData.composition}" onclick="window.open('${imgData.url}', '_blank')"><div class="scene-dialogue" id="scene-dialogue"></div>`;

        if (imgData.dialogue) {
            showSceneDialogue(imgData.dialogue, imgData.charName);
        }
    }

    function displayGeneratedImages(activeIndex) {
        const sceneDiv = document.getElementById('scene-image');
        const thumbsDiv = document.getElementById('scene-thumbnails');

        if (generatedImages.length === 0) return;

        currentImageIndex = activeIndex;
        const activeItem = generatedImages[activeIndex];

        // タイプに応じて表示を切り替え
        if (activeItem.type === 'narration') {
            // 地の文アイテムに保存された場所画像があればそれを使用、なければ現在の場所画像を使用
            const placeImage = activeItem.placeImage || getCurrentPlaceImage();
            const sceneDiv = document.getElementById('scene-image');
            const bgHtml = placeImage ? `<div class="scene-bg-image" style="background-image: url('${placeImage}');"></div>` : '';
            sceneDiv.innerHTML = `
                ${bgHtml}
                <div class="scene-narration">
                    <p>${activeItem.narration.replace(/\n/g, '<br>')}</p>
                </div>
                <div class="scene-dialogue" id="scene-dialogue"></div>
            `;
            currentSceneUrl = '';
        } else {
            currentSceneUrl = activeItem.url;

            // 既存のimg要素を再利用、なければ作成
            let img = sceneDiv.querySelector('img.scene-main-image');
            let dialogueDiv = document.getElementById('scene-dialogue');

            if (!img) {
                sceneDiv.innerHTML = '';
                img = document.createElement('img');
                img.className = 'scene-main-image';
                img.style.cssText = 'max-width:100%;max-height:100%;object-fit:contain;border-radius:8px;cursor:pointer;';
                img.onclick = () => window.open(img.src, '_blank');
                sceneDiv.appendChild(img);

                dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'scene-dialogue';
                dialogueDiv.id = 'scene-dialogue';
                sceneDiv.appendChild(dialogueDiv);
            }

            // 地の文表示を削除（存在する場合）
            const narrationDiv = sceneDiv.querySelector('.scene-narration');
            if (narrationDiv) narrationDiv.remove();

            // srcのみ更新（キャッシュ済みなのでちらつかない）
            img.src = activeItem.url;
            img.alt = activeItem.composition;
            img.style.display = '';

            // この画像に紐付くセリフを表示
            if (activeItem.dialogue) {
                showSceneDialogue(activeItem.dialogue, activeItem.charName);
            } else {
                dialogueDiv.style.display = 'none';
            }
        }

        // サムネイルのアクティブ状態のみ更新（DOM再構築しない）
        updateThumbnails(activeIndex);
    }

    // サムネイルのアクティブ状態を更新（再構築せずclassのみ変更）
    function updateThumbnails(activeIndex) {
        const thumbsDiv = document.getElementById('scene-thumbnails');
        const thumbs = thumbsDiv.querySelectorAll('.scene-thumb');

        // サムネイル数が一致しない場合のみ再構築
        if (thumbs.length !== generatedImages.length) {
            rebuildThumbnails(activeIndex);
            return;
        }

        // classのみ更新
        thumbs.forEach((thumb, i) => {
            thumb.classList.toggle('active', i === activeIndex);
        });
    }

    // サムネイルを再構築
    function rebuildThumbnails(activeIndex) {
        const thumbsDiv = document.getElementById('scene-thumbnails');

        if (generatedImages.length > 1) {
            thumbsDiv.innerHTML = generatedImages.map((item, i) => {
                if (item.type === 'narration') {
                    const displayName = item.actionName || '文';
                    return `<div class="scene-thumb narration-thumb ${i === activeIndex ? 'active' : ''}"
                                onclick="displayGeneratedImages(${i})"
                                title="${displayName}"><span>${displayName}</span></div>`;
                } else {
                    return `<img src="${item.url}" class="scene-thumb ${i === activeIndex ? 'active' : ''}"
                                onclick="displayGeneratedImages(${i})"
                                title="${item.composition} [${item.quality || ''}]">`;
                }
            }).join('');
            thumbsDiv.style.display = 'flex';
        } else {
            thumbsDiv.style.display = 'none';
        }
    }

    // キーボード操作
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        if (e.key === 'ArrowLeft' && generatedImages.length > 1) {
            const newIndex = (currentImageIndex - 1 + generatedImages.length) % generatedImages.length;
            displayGeneratedImages(newIndex);
        } else if (e.key === 'ArrowRight' && generatedImages.length > 1) {
            const newIndex = (currentImageIndex + 1) % generatedImages.length;
            displayGeneratedImages(newIndex);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            const actionSelect = document.getElementById('action');
            const currentIdx = parseInt(actionSelect.value);
            if (currentIdx < actions.length - 1) {
                actionSelect.value = currentIdx + 1;
                executeAction();
            } else if (actions.length > 0) {
                actionSelect.value = 0;
                executeAction();
            }
        }
    });

    async function getCharacterReaction(action, patternCount = 1) {
        const charIdx = document.getElementById('character').value;
        if (charIdx === '') return [];

        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) return [];

        const char = characters[charIdx];
        const placeIdx = document.getElementById('place').value;
        const place = placeIdx !== '' ? places[placeIdx] : null;

        try {
            const systemPrompt = buildCharacterSystemPrompt(char, true, patternCount);
            const actionContext = `[アクション: ${action.name}]\n[状況: ${action.prompt || action.name}]`;

            const messages = [
                { role: 'system', content: systemPrompt },
                ...chatHistory.map(m => ({ role: m.role, content: m.content })),
                { role: 'user', content: actionContext }
            ];

            const chatModel = document.getElementById('chatModel').value || 'x-ai/grok-4.1-fast';
            console.log('[Reaction] Model:', chatModel);
            console.log('[Reaction] Messages:', JSON.stringify(messages, null, 2));

            const streamStartTime = Date.now();

            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${chatApiKey}`
                },
                body: JSON.stringify({
                    model: chatModel,
                    messages: messages,
                    stream: true
                })
            });

            if (!response.ok) {
                const error = await response.json();
                console.error('Reaction API error:', JSON.stringify(error, null, 2));
                addMessage('system', `リアクションエラー: ${JSON.stringify(error.error)}`);
                return [];
            }

            // ストリーミング読み取り
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullContent = '';
            let firstChunkLogged = false;
            let narrationEnded = false;

            // 地の文ストリーミング表示用のエリアを準備
            const sceneDiv = document.getElementById('scene-image');

            // タイプライター表示用
            let textBuffer = '';       // 表示待ちテキスト（タグ除去済み）
            let displayedLength = 0;   // 表示済み文字数
            let typewriterTimer = null;
            const CHAR_DELAY = 50;     // 1文字あたりのミリ秒（ゆっくり）

            // タグを除去して表示用テキストを取得
            function getDisplayText(text) {
                return text
                    .replace(/\[パターン\d+\]/g, '')
                    .replace(/\[地の文\]/g, '')
                    .replace(/\[セリフ\][\s\S]*$/s, '')  // [セリフ]以降を削除
                    .trim();
            }

            // タイプライター表示を開始
            function startTypewriter() {
                if (typewriterTimer) return;
                typewriterTimer = setInterval(() => {
                    if (displayedLength < textBuffer.length) {
                        displayedLength++;
                        const displayText = textBuffer.substring(0, displayedLength);
                        const narrationEl = document.querySelector('#streaming-narration p');
                        if (narrationEl) {
                            narrationEl.innerHTML = displayText.replace(/\n/g, '<br>');
                        }
                    }
                }, CHAR_DELAY);
            }

            // タイプライター表示を停止
            function stopTypewriter() {
                if (typewriterTimer) {
                    clearInterval(typewriterTimer);
                    typewriterTimer = null;
                }
            }

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                // 最初のチャンク受信時刻 & 表示エリア初期化
                if (!firstChunkLogged) {
                    console.log(`[Timing] LLM受信開始: ${Date.now() - streamStartTime}ms`);
                    firstChunkLogged = true;
                    // 地の文ストリーミング表示用のエリアを作成（背景画像付き）
                    const placeImage = getCurrentPlaceImage();
                    const bgHtml = placeImage ? `<div class="scene-bg-image" style="background-image: url('${placeImage}');"></div>` : '';
                    sceneDiv.innerHTML = `
                        ${bgHtml}
                        <div class="scene-narration" id="streaming-narration">
                            <p></p>
                        </div>
                        <div class="scene-dialogue" id="scene-dialogue"></div>
                    `;
                    startTypewriter();
                }

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(data);
                            const delta = parsed.choices?.[0]?.delta?.content || '';
                            fullContent += delta;

                            // [セリフ]が出てきたら地の文完了
                            if (!narrationEnded && fullContent.includes('[セリフ]')) {
                                console.log(`[Timing] 地の文完了: ${Date.now() - streamStartTime}ms`);
                                narrationEnded = true;
                            }

                            // バッファを更新（タグ除去済みテキスト）
                            if (!narrationEnded) {
                                textBuffer = getDisplayText(fullContent);
                            }
                        } catch (e) {
                            // パースエラーは無視
                        }
                    }
                }
            }

            // ストリーム終了後、残りの文字を表示しきるまで待つ
            await new Promise(resolve => {
                const checkComplete = setInterval(() => {
                    if (displayedLength >= textBuffer.length) {
                        clearInterval(checkComplete);
                        stopTypewriter();
                        resolve();
                    }
                }, 50);
            });

            console.log('[Reaction] 返答:', fullContent);
            chatHistory.push({ role: 'user', content: actionContext });

            // 複数パターンをパースして返す
            return parseMultiplePatterns(fullContent, patternCount);
        } catch (error) {
            console.error('Reaction error:', error);
            addMessage('system', `リアクション通信エラー: ${error.message}`);
            return [];
        }
    }

    function parseMultiplePatterns(reply, expectedCount) {
        const patterns = [];

        // [パターンN]で分割
        const patternRegex = /\[パターン(\d+)\]/g;
        const parts = reply.split(patternRegex);

        // parts[0]は最初の[パターン1]より前のテキスト（空か無視）
        // parts[1]は"1", parts[2]はパターン1の内容, parts[3]は"2", parts[4]はパターン2の内容...
        for (let i = 1; i < parts.length; i += 2) {
            const content = parts[i + 1] || '';
            const narrationMatch = content.match(/\[地の文\]\s*([\s\S]*?)(?=\[セリフ\]|$)/);
            const dialogueMatch = content.match(/\[セリフ\]\s*([\s\S]*?)(?=\[パターン|$)/);

            patterns.push({
                narration: narrationMatch ? narrationMatch[1].trim() : '',
                dialogue: dialogueMatch ? dialogueMatch[1].trim() : ''
            });
        }

        // パターンが見つからない場合、旧形式でパース
        if (patterns.length === 0) {
            const narrationMatch = reply.match(/\[地の文\]\s*([\s\S]*?)(?=\[セリフ\]|$)/);
            const dialogueMatch = reply.match(/\[セリフ\]\s*([\s\S]*?)$/);
            patterns.push({
                narration: narrationMatch ? narrationMatch[1].trim() : '',
                dialogue: dialogueMatch ? dialogueMatch[1].trim() : reply.trim()
            });
        }

        // 足りない分は最後のパターンで埋める
        while (patterns.length < expectedCount) {
            patterns.push(patterns[patterns.length - 1] || { narration: '', dialogue: '' });
        }

        return patterns;
    }

    function displayReactionPatterns(patterns) {
        // 最初のパターンをチャット欄に表示
        if (patterns.length > 0 && patterns[0]) {
            if (patterns[0].narration) {
                addMessage('narration', patterns[0].narration);
            }
            if (patterns[0].dialogue) {
                addMessage('assistant', patterns[0].dialogue);
            }
        }
    }

    function showSceneDialogue(text, charName = null) {
        const dialogueDiv = document.getElementById('scene-dialogue');

        // 引数で渡された名前を優先、なければ現在選択中のキャラクター名を使用
        let displayName = charName;
        if (!displayName) {
            const charIdx = document.getElementById('character').value;
            const char = charIdx !== '' ? characters[charIdx] : null;
            displayName = char?.name;
        }

        if (displayName) {
            dialogueDiv.innerHTML = `<span class="char-name">${displayName}</span>${text}`;
        } else {
            dialogueDiv.textContent = text;
        }

        // チャット欄と同じフォントサイズを適用
        const messagesDiv = document.getElementById('chat-messages');
        dialogueDiv.classList.remove('font-small', 'font-large');
        if (messagesDiv.classList.contains('font-small')) {
            dialogueDiv.classList.add('font-small');
        } else if (messagesDiv.classList.contains('font-large')) {
            dialogueDiv.classList.add('font-large');
        }

        dialogueDiv.style.display = 'block';
    }

    // チャット機能
    function addMessage(role, content) {
        const messagesDiv = document.getElementById('chat-messages');
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${role}`;
        msgDiv.textContent = content;
        messagesDiv.appendChild(msgDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        // APIに送信可能なroleのみ履歴に追加
        if (role === 'user' || role === 'assistant') {
            chatHistory.push({ role, content });
        }
    }

    function clearChat() {
        document.getElementById('chat-messages').innerHTML = '';
        chatHistory = [];
    }

    async function sendMessage() {
        const input = document.getElementById('chat-input');
        const message = input.value.trim();
        if (!message) return;

        const charIdx = document.getElementById('character').value;
        if (charIdx === '') {
            alert('キャラクターを選択してください');
            return;
        }

        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) {
            alert('OpenRouter API Keyを設定してください');
            toggleSettings();
            return;
        }

        const char = characters[charIdx];
        input.value = '';
        addMessage('user', message);

        try {
            const systemPrompt = buildCharacterSystemPrompt(char);
            const messages = [
                { role: 'system', content: systemPrompt },
                ...chatHistory.map(m => ({ role: m.role, content: m.content }))
            ];

            const chatModel = document.getElementById('chatModel').value || 'x-ai/grok-4.1-fast';
            console.log('[Chat] Model:', chatModel);
            console.log('[Chat] Messages:', JSON.stringify(messages, null, 2));

            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${chatApiKey}`
                },
                body: JSON.stringify({
                    model: chatModel,
                    messages: messages,
                    stream: false
                })
            });

            if (!response.ok) {
                const error = await response.json();
                addMessage('system', `エラー: ${error.error?.message || response.statusText}`);
                return;
            }

            const data = await response.json();
            console.log('[Chat] レスポンス:', data);
            if (data.choices && data.choices[0]) {
                const reply = data.choices[0].message.content;
                console.log('[Chat] 返答:', reply);
                addMessage('assistant', reply);
            }
        } catch (error) {
            console.error(error);
            addMessage('system', `通信エラー: ${error.message}`);
        }
    }

    function buildCharacterSystemPrompt(char, isAction = false, patternCount = 1) {
        const placeIdx = document.getElementById('place').value;
        const place = placeIdx !== '' ? places[placeIdx] : null;

        let prompt = `あなたは「${char.name}」というキャラクターです。`;
        if (char.series) prompt += `作品「${char.series}」に登場します。`;
        if (char.profile) prompt += `\n\nプロフィール: ${char.profile}`;
        if (place) prompt += `\n\n現在の場所: ${place.name}`;

        if (isAction) {
            prompt += `\n\n【出力形式】
${patternCount}パターンの反応を生成してください。各パターンは以下の形式で出力：

[パターン1]
[地の文]
官能小説のような生々しい描写。身体の状態、性的な部位の様子、肌の感触、体温、濡れ具合、締め付けなどを具体的かつ官能的に表現。

[セリフ]
キャラクターの声、吐息、言葉。「」で囲む。

[パターン2]
[地の文]
（別の描写バリエーション）

[セリフ]
（別のセリフバリエーション）

...以下同様に${patternCount}パターンまで

必ず[パターンN]、[地の文]、[セリフ]のタグを使用してください。各パターンは異なる表現・セリフにしてください。`;
        } else {
            prompt += '\n\nキャラクターになりきって、短く自然な会話で応答してください。';
        }
        return prompt;
    }
</script>

</body>
</html>
