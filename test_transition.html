<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transition Test</title>
    <link rel="stylesheet" href="css/common.css">
    <style>
        html, body {
            padding: 0;
            margin: 0;
            overflow: hidden;
            height: 100%;
        }

        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: 100vh;
        }

        /* サイドバー */
        .sidebar {
            background: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 15px;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .sidebar-header h2 {
            margin: 0;
            color: #4a9eff;
            font-size: 1rem;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            overscroll-behavior: contain;
            padding: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.9rem;
        }

        .current-state {
            background: #222;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .current-state h3 {
            margin: 0 0 10px 0;
            color: #4a9eff;
            font-size: 0.9rem;
        }

        .state-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 0.85rem;
        }

        .state-item:last-child {
            border-bottom: none;
        }

        .state-label {
            color: #888;
        }

        .state-value {
            color: #fff;
            text-align: right;
            max-width: 150px;
        }

        .memo-line {
            font-size: 0.8rem;
            color: #aaa;
            padding: 3px 0;
        }

        .sidebar-footer {
            padding: 15px;
            background: #222;
            border-top: 1px solid #333;
        }

        .sidebar-footer input {
            width: 100%;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        /* チャットエリア */
        .chat-area {
            display: flex;
            flex-direction: column;
            background: #111;
            overflow: hidden;
        }

        .chat-header {
            padding: 15px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .chat-header h2 {
            margin: 0;
            color: #fff;
            font-size: 1.1rem;
            flex: 1;
        }

        /* ページ表示エリア（固定表示） */
        .page-area {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: #111;
        }

        #page-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            overflow: hidden;
            position: relative;
        }

        .page-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .page-image {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .page-image .placeholder {
            color: #666;
            font-size: 0.9rem;
        }

        .page-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            line-height: 1.8;
            font-size: 1rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.6);
            max-height: 100%;
            overflow-y: auto;
        }

        .page-text.system-text {
            position: static;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #888;
            height: 100%;
            max-height: none;
            background: #1a1a1a;
        }

        /* 画像なしのページ（dialogue等）*/
        .page-content:not(:has(.page-image)) .page-text {
            position: static;
            height: 100%;
            max-height: none;
            background: #1a1a1a;
        }

        .page-label {
            background: #4a9eff;
            color: #fff;
            padding: 4px 12px;
            font-size: 0.8rem;
            display: inline-block;
            margin-bottom: 12px;
            border-radius: 4px;
        }

        .page-label.character {
            background: #e53e3e;
        }

        .page-label.system {
            background: #555;
        }

        /* ページナビゲーション */
        .page-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-top: 1px solid #333;
        }

        .page-nav button {
            padding: 8px 16px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-nav button:hover:not(:disabled) {
            background: #3a3a3a;
            border-color: #4a9eff;
        }

        .page-nav button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #page-indicator {
            color: #888;
            font-size: 0.9rem;
            min-width: 60px;
            text-align: center;
        }

        .page-nav .latest-btn {
            font-size: 0.8rem;
            padding: 6px 12px;
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .page-nav .latest-btn:hover:not(:disabled) {
            background: #3a8eef;
        }

        .action-name {
            font-weight: bold;
            color: #90cdf4;
            margin-bottom: 5px;
        }

        .action-prompt {
            font-size: 0.85rem;
            color: #a0aec0;
        }

        .transition-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .transition-arrow {
            color: #4a9eff;
            font-size: 1.2rem;
        }

        /* コマンド入力エリア */
        .command-area {
            padding: 12px 20px;
            background: #1a1a1a;
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .command-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .command-type-buttons {
            display: flex;
            gap: 4px;
        }

        .command-type-btn {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a2a;
            color: #888;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .command-type-btn:hover {
            background: #3a3a3a;
            border-color: #4a9eff;
        }

        .command-type-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }

        #command-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.9rem;
        }

        #command-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .command-execute-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #4a9eff;
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .command-execute-btn:hover {
            background: #3a8eef;
        }

        .command-target-select {
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.85rem;
            min-width: 150px;
        }

        .command-target-select:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .action-btn.current {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        #status {
            font-size: 0.8rem;
            margin-top: 8px;
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            .sidebar {
                border-right: none;
                border-bottom: 1px solid #333;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>

<div class="app-container">
    <!-- サイドバー -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>Transition Test</h2>
        </div>
        <div class="sidebar-content">
            <!-- キャラクター1ステータス -->
            <div class="current-state">
                <h3>キャラクター1</h3>
                <div class="state-item">
                    <span class="state-label">名前</span>
                    <span class="state-value" id="char1-name">未選択</span>
                </div>
                <div class="state-item">
                    <span class="state-label">現在地</span>
                    <span class="state-value" id="char1-place">未選択</span>
                </div>
                <div class="state-item">
                    <span class="state-label">状態</span>
                    <span class="state-value" id="char1-action">未選択</span>
                </div>
                <div class="state-item">
                    <span class="state-label">関係性</span>
                    <span class="state-value" id="char1-relationship">未設定</span>
                </div>
                <div class="memo-line" id="char1-memo"></div>
            </div>

            <!-- キャラクター2ステータス -->
            <div class="current-state">
                <h3>キャラクター2</h3>
                <div class="state-item">
                    <span class="state-label">名前</span>
                    <span class="state-value" id="char2-name">未選択</span>
                </div>
                <div class="state-item">
                    <span class="state-label">現在地</span>
                    <span class="state-value" id="char2-place">未選択</span>
                </div>
                <div class="state-item">
                    <span class="state-label">状態</span>
                    <span class="state-value" id="char2-action">未選択</span>
                </div>
                <div class="state-item">
                    <span class="state-label">関係性</span>
                    <span class="state-value" id="char2-relationship">未設定</span>
                </div>
                <div class="memo-line" id="char2-memo"></div>
            </div>

            <!-- ユーザーステータス -->
            <div class="current-state">
                <h3>ユーザー</h3>
                <div class="state-item">
                    <span class="state-label">現在地</span>
                    <span class="state-value" id="user-place">未選択</span>
                </div>
            </div>

            <button class="btn btn-primary" onclick="startInitialSetup()" style="width:100%; margin-bottom:15px;">初期設定</button>
        </div>
        <div class="sidebar-footer">
            <input type="text" id="gasUrl" placeholder="GAS URL" style="margin-bottom:8px;">
            <button class="btn btn-primary" onclick="loadAllFromGas()" style="width:100%; margin-bottom:12px;">GAS読み込み</button>
            <input type="password" id="chatApiKey" placeholder="OpenRouter API Key" style="margin-bottom:8px;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                <input type="password" id="runwareApiKey" placeholder="Runware API Key" style="flex:1; margin-bottom:0;">
                <button class="btn" id="imageGenToggle" onclick="toggleImageGen()" style="padding:8px 12px; font-size:0.8rem;">ON</button>
            </div>
            <select id="modelSelect" onchange="onModelSelect()" style="width:100%; padding:8px; border:1px solid #333; border-radius:4px; background:#2a2a2a; color:#fff; font-size:0.85rem; margin-bottom:8px;">
                <option value="">-- モデル選択 --</option>
            </select>
            <div id="status"></div>
        </div>
    </div>

    <!-- チャットエリア -->
    <div class="chat-area">
        <div class="chat-header">
            <h2 id="chat-title">アクション遷移テスト</h2>
            <button class="btn btn-small" onclick="clearChat()" style="background:#555;">クリア</button>
        </div>
        <div class="page-area">
            <div id="page-view"></div>
            <div class="page-nav">
                <button id="prev-page-btn" onclick="prevPage()" disabled>&lt;</button>
                <span id="page-indicator">-- / --</span>
                <button id="next-page-btn" onclick="nextPage()" disabled>&gt;</button>
                <button class="latest-btn" onclick="goToLatestPage()">最新</button>
            </div>
        </div>
        <div class="command-area">
            <div class="command-row">
                <button class="command-type-btn active" onclick="toggleTargetType()" id="target-toggle">移動</button>
                <select class="command-target-select" id="target-select" onchange="onTargetSelect()">
                    <option value="">-- 選択 --</option>
                </select>
                <button class="command-type-btn" onclick="toggleMoveMode()" id="move-mode-toggle">一人で</button>
            </div>
            <div class="command-row">
                <button class="command-type-btn active" onclick="toggleCommandType()" id="cmd-toggle">発言</button>
                <input type="text" id="command-input" placeholder="発言内容を入力..." onkeydown="if(event.key==='Enter')executeCommand()">
                <button class="command-execute-btn" onclick="executeCommand()">実行</button>
            </div>
        </div>
    </div>
</div>

<script src="js/constants.js"></script>
<script src="js/gas-api.js"></script>
<script src="js/storage.js"></script>
<script src="js/data-parser.js"></script>
<script src="js/ui-utils.js"></script>
<script src="js/prompt-utils.js"></script>
<script src="js/runware-api.js"></script>
<script>
    const CACHE_KEY = 'transition_test_cache';

    // データストア
    let models = {};
    let characters = [];
    let places = [];
    let actions = [];
    let relationships = [];  // 関係性データ
    let transitions = [];  // 遷移データ（将来用）
    let promptTemplates = {};  // LLMプロンプトテンプレート

    // 現在の状態（後方互換用）
    let currentState = {
        characterIndex: -1,
        placeIndex: -1,
        actionIndex: -1
    };

    // ユーザーステータス
    let userState = {
        placeIndex: -1
    };

    // キャラクターステータス（2人分）
    let characterStatus = [
        {
            characterIndex: -1,
            placeIndex: -1,
            actionIndex: -1,   // 現在のアクション
            relationshipId: 'rel_001',  // 関係性ID
            memo: ''  // メモ
        },
        {
            characterIndex: -1,
            placeIndex: -1,
            actionIndex: -1,
            relationshipId: 'rel_001',
            memo: ''
        }
    ];

    // コマンドタイプ
    let currentCommandType = 'speech';

    // ターゲットタイプ（移動/アクション）
    let currentTargetType = 'move';

    // チャット履歴
    let chatHistory = [];

    // 履歴
    let actionHistory = [];

    // ページ履歴（ページ単位表示用）
    let pages = [];
    let currentPageIndex = -1;

    // ストレージキー
    const CHAT_API_KEY = 'transition_chat_api_key';
    const RUNWARE_API_KEY = 'transition_runware_api_key';
    const IMAGE_GEN_ENABLED_KEY = 'transition_image_gen_enabled';

    // 画像生成On/Off
    let imageGenEnabled = true;

    // 選択中のモデルID
    let selectedModelId = '';
    const SELECTED_MODEL_KEY = 'transition_selected_model';

    // 移動モード（一人で/一緒に）
    let moveWithCompanion = false;

    // 移動モード切り替え
    function toggleMoveMode() {
        moveWithCompanion = !moveWithCompanion;
        updateMoveModeButton();
    }

    function updateMoveModeButton() {
        const btn = document.getElementById('move-mode-toggle');
        if (btn) {
            btn.textContent = moveWithCompanion ? '一緒に' : '一人で';
            btn.classList.toggle('active', moveWithCompanion);
        }
    }

    // 画像生成On/Off切り替え
    function toggleImageGen() {
        imageGenEnabled = !imageGenEnabled;
        localStorage.setItem(IMAGE_GEN_ENABLED_KEY, imageGenEnabled ? 'on' : 'off');
        updateImageGenButton();
    }

    function updateImageGenButton() {
        const btn = document.getElementById('imageGenToggle');
        if (btn) {
            btn.textContent = imageGenEnabled ? 'ON' : 'OFF';
            btn.style.background = imageGenEnabled ? '#4a9eff' : '#555';
        }
    }

    // モデル選択プルダウン更新
    function updateModelSelect() {
        const select = document.getElementById('modelSelect');
        if (!select) return;

        select.innerHTML = '<option value="">-- モデル選択 --</option>';
        Object.keys(models).forEach(modelId => {
            const model = models[modelId];
            const selected = modelId === selectedModelId ? ' selected' : '';
            select.innerHTML += `<option value="${modelId}"${selected}>${model.name || modelId}</option>`;
        });
    }

    // モデル選択変更時
    function onModelSelect() {
        const select = document.getElementById('modelSelect');
        selectedModelId = select.value;
        localStorage.setItem(SELECTED_MODEL_KEY, selectedModelId);
        console.log('[モデル選択]', selectedModelId);
    }

    // ターゲットタイプ切り替え（移動/行為）
    function toggleTargetType() {
        currentTargetType = currentTargetType === 'move' ? 'action' : 'move';
        document.getElementById('target-toggle').textContent = currentTargetType === 'move' ? '移動' : '行為';
        updateTargetSelect();
    }

    function setTargetType(type) {
        currentTargetType = type;
        document.getElementById('target-toggle').textContent = type === 'move' ? '移動' : '行為';
        updateTargetSelect();
    }

    // ターゲット選択プルダウン更新
    function updateTargetSelect() {
        const select = document.getElementById('target-select');
        select.innerHTML = '';

        if (currentTargetType === 'move') {
            places.forEach((place, i) => {
                if (place.command_list === 'use') {
                    const selected = i === userState.placeIndex ? ' selected' : '';
                    select.innerHTML += `<option value="${i}"${selected}>${place.name}</option>`;
                }
            });
        } else {
            actions.forEach((action, i) => {
                if (action.command_list === 'use') {
                    const selected = i === currentState.actionIndex ? ' selected' : '';
                    select.innerHTML += `<option value="${i}"${selected}>${action.name}</option>`;
                }
            });
        }
    }

    // ターゲット選択時
    async function onTargetSelect() {
        const select = document.getElementById('target-select');
        const index = parseInt(select.value);
        if (isNaN(index) || index < 0) return;

        if (currentTargetType === 'move') {
            // ユーザーの場所変更
            const previousPlace = userState.placeIndex >= 0 ? places[userState.placeIndex] : null;

            // 「一緒に」モードの場合、現在地のキャラクターも一緒に移動
            let companion = null;
            if (moveWithCompanion) {
                console.log('[移動モード] 一緒にモード ON, ユーザー現在地:', userState.placeIndex);
                const charAtLocation = getCharacterAtUserLocation();
                console.log('[移動モード] 現在地のキャラ:', charAtLocation);
                if (charAtLocation) {
                    companion = charAtLocation;
                    // characterStatus配列を直接更新
                    const statusIndex = characterStatus.indexOf(charAtLocation.status);
                    console.log('[移動モード] statusIndex:', statusIndex, '移動先:', index);
                    if (statusIndex >= 0) {
                        characterStatus[statusIndex].placeIndex = index;
                        // 移動先のデフォルトアクションに変更
                        const newPlace = places[index];
                        if (newPlace && newPlace.default_action) {
                            const newActionIndex = actions.findIndex(a => a.action_id === newPlace.default_action);
                            if (newActionIndex >= 0) {
                                characterStatus[statusIndex].actionIndex = newActionIndex;
                                console.log('[一緒に移動] アクション変更:', actions[newActionIndex]?.name);
                            }
                        }
                    }
                    updateCharacterStatusDisplay();
                    console.log('[一緒に移動]', charAtLocation.character.name, '→', places[index]?.name);
                }
            }

            userState.placeIndex = index;
            updateUserStatusDisplay();
            const newPlace = places[index];

            // ページ生成
            await generatePages('move', '', previousPlace, newPlace, companion);
        } else {
            // アクション選択（実行はしない）
            currentState.actionIndex = index;
            console.log('[行為選択]', actions[index]?.name);
        }
    }

    // アクション実行（ボタンまたはEnterキーで呼び出し）
    async function runSelectedAction() {
        if (currentTargetType !== 'action' || currentState.actionIndex < 0) return;
        await executeAction(currentState.actionIndex);
    }

    // コマンドタイプ切り替え（発言→行為→脚本→発言...）
    const commandTypes = ['speech', 'action', 'scenario'];
    const commandLabels = { speech: '発言', action: '行為', scenario: '脚本' };
    const commandPlaceholders = {
        speech: '発言内容を入力...',
        action: '行為内容を入力...',
        scenario: '脚本指示を入力...'
    };

    function toggleCommandType() {
        const currentIndex = commandTypes.indexOf(currentCommandType);
        const nextIndex = (currentIndex + 1) % commandTypes.length;
        currentCommandType = commandTypes[nextIndex];
        document.getElementById('cmd-toggle').textContent = commandLabels[currentCommandType];
        document.getElementById('command-input').placeholder = commandPlaceholders[currentCommandType];
    }

    function setCommandType(type) {
        currentCommandType = type;
        document.getElementById('cmd-toggle').textContent = commandLabels[type];
        document.getElementById('command-input').placeholder = commandPlaceholders[type];
    }

    // コマンド実行
    async function executeCommand() {
        const input = document.getElementById('command-input');
        const text = input.value.trim();
        const hasAction = currentTargetType === 'action' && currentState.actionIndex >= 0;

        // テキストも行為もない場合は何もしない
        if (!text && !hasAction) return;

        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) {
            alert('OpenRouter API Key を入力してください');
            return;
        }
        localStorage.setItem(CHAT_API_KEY, chatApiKey);

        if (userState.placeIndex < 0) {
            alert('初期設定を実行してください');
            return;
        }

        // 行為のみ（テキストなし）
        if (!text && hasAction) {
            await runSelectedAction();
            return;
        }

        // 行為＋テキスト（発言しながら行為）
        if (text && hasAction) {
            const action = actions[currentState.actionIndex];
            addCommandMessage('行為＋発言', `${action.name} / 「${text}」`);
            input.value = '';
            await generatePages('action_with_speech', text, null, null);
            return;
        }

        // テキストのみ
        const typeLabels = {
            speech: '発言',
            action: '行為',
            scenario: '脚本'
        };

        addCommandMessage(typeLabels[currentCommandType], text);
        input.value = '';

        // ページ生成
        await generatePages(currentCommandType, text, null, null);
    }

    // Grok API呼び出し
    async function sendToGrok(commandType, userInput) {
        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        const char = characters[currentState.characterIndex];
        const place = currentState.placeIndex >= 0 ? places[currentState.placeIndex] : null;
        const action = currentState.actionIndex >= 0 ? actions[currentState.actionIndex] : null;

        // システムプロンプト構築（テンプレートから取得）
        const charTemplate = getPromptTemplate(promptTemplates, 'llm_002', { name: char.name });
        // テンプレートが " + " で分割されている場合、前半と後半に分ける
        const templateParts = charTemplate ? charTemplate.split(' + ') : [];
        let systemPrompt = templateParts[0] || `あなたは「${char.name}」というキャラクターです。`;
        if (char.series) systemPrompt += `作品「${char.series}」に登場します。`;
        if (char.profile) systemPrompt += `\n\nプロフィール: ${char.profile}`;
        if (place) systemPrompt += `\n\n現在の場所: ${place.name}`;
        if (action) systemPrompt += `\n\n現在のアクション: ${action.name}`;
        systemPrompt += `\n\n${templateParts[1] || 'キャラクターとして自然に応答してください。'}`;

        // ユーザーメッセージ構築
        let userMessage = '';
        if (commandType === 'speech') {
            userMessage = `[プレイヤーの発言]: ${userInput}`;
        } else if (commandType === 'action') {
            userMessage = `[プレイヤーの行為]: ${userInput}\n\nこの行為に対するキャラクターの反応を描写してください。`;
        } else if (commandType === 'scenario') {
            userMessage = `[脚本指示]: ${userInput}\n\nこの状況でキャラクターがどう反応するか描写してください。`;
        }

        chatHistory.push({ role: 'user', content: userMessage });

        const messages = [
            { role: 'system', content: systemPrompt },
            ...chatHistory
        ];

        console.log('[Grok] モデル:', 'x-ai/grok-4.1-fast');
        console.log('[Grok] システムプロンプト:', systemPrompt);
        console.log('[Grok] メッセージ履歴:', JSON.stringify(chatHistory, null, 2));
        console.log('[Grok] 送信メッセージ:', JSON.stringify(messages, null, 2));

        // ストリーミング用のメッセージ要素を作成
        const messagesDiv = document.getElementById('chat-messages');
        const msgDiv = document.createElement('div');
        msgDiv.className = 'message transition';
        msgDiv.innerHTML = `<div class="action-name">${char.name}</div><div class="action-prompt" id="streaming-content">...</div>`;
        messagesDiv.appendChild(msgDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        const streamingContent = document.getElementById('streaming-content');
        let fullReply = '';

        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${chatApiKey}`
                },
                body: JSON.stringify({
                    model: 'x-ai/grok-4.1-fast',
                    messages: messages,
                    stream: true
                })
            });

            if (!response.ok) {
                const error = await response.json();
                streamingContent.textContent = `エラー: ${error.error?.message || response.statusText}`;
                streamingContent.removeAttribute('id');
                return;
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(data);
                            const delta = parsed.choices?.[0]?.delta?.content;
                            if (delta) {
                                fullReply += delta;
                                streamingContent.innerHTML = fullReply.replace(/\n/g, '<br>');
                                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                            }
                        } catch (e) {
                            // JSONパースエラーは無視
                        }
                    }
                }
            }

            // ストリーミング完了
            streamingContent.removeAttribute('id');
            if (fullReply) {
                chatHistory.push({ role: 'assistant', content: fullReply });
                console.log('[Grok] 応答完了:', fullReply);
            }
        } catch (error) {
            console.error(error);
            streamingContent.textContent = `通信エラー: ${error.message}`;
            streamingContent.removeAttribute('id');
        }
    }

    // コマンドメッセージ追加（コンソールのみ）
    function addCommandMessage(type, text) {
        console.log(`[${type}]`, text);
    }

    // アシスタントメッセージ追加
    function addAssistantMessage(name, text) {
        addPage({
            type: 'dialogue',
            image: null,
            text: text,
            label: name
        });
    }

    // 初期化
    document.addEventListener('DOMContentLoaded', () => {
        const settings = loadSettings(STORAGE_KEYS.GAS_URL, STORAGE_KEYS.API_KEY);
        if (settings.gasUrl) document.getElementById('gasUrl').value = settings.gasUrl;

        // API Key 復元
        const savedApiKey = localStorage.getItem(CHAT_API_KEY);
        if (savedApiKey) document.getElementById('chatApiKey').value = savedApiKey;

        const savedRunwareKey = localStorage.getItem(RUNWARE_API_KEY);
        if (savedRunwareKey) document.getElementById('runwareApiKey').value = savedRunwareKey;

        // 画像生成On/Off状態を復元
        const savedImageGenEnabled = localStorage.getItem(IMAGE_GEN_ENABLED_KEY);
        imageGenEnabled = savedImageGenEnabled !== 'off';
        updateImageGenButton();

        // モデル選択の復元
        const savedModelId = localStorage.getItem(SELECTED_MODEL_KEY);
        if (savedModelId) selectedModelId = savedModelId;

        // ターゲットタイプ初期化
        setTargetType('move');

        loadCachedData();

        // キーボードナビゲーション
        document.addEventListener('keydown', (e) => {
            // 入力フィールドにフォーカスがある場合は無視
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                nextPage();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                prevPage();
            }
        });
    });

    function saveCachedData() {
        localStorage.setItem(CACHE_KEY, JSON.stringify({ models, characters, places, actions, relationships, promptTemplates }));
    }

    function loadCachedData() {
        try {
            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
                const data = JSON.parse(cached);
                models = data.models || {};
                characters = data.characters || [];
                places = data.places || [];
                actions = data.actions || [];
                relationships = data.relationships || [];
                promptTemplates = data.promptTemplates || {};
                updateAllSelects();
                updateTargetSelect();
                updateModelSelect();
                if (actions.length > 0) {
                    addSystemMessage(`キャッシュから復元: ${characters.length}キャラ, ${places.length}場所, ${actions.length}アクション`);
                }
            }
        } catch (e) {
            console.error('Cache load error:', e);
        }
    }

    async function loadAllFromGas() {
        const baseUrl = document.getElementById('gasUrl').value.trim();
        if (!baseUrl) {
            alert('GAS URLを入力してください');
            return;
        }

        localStorage.setItem(STORAGE_KEYS.GAS_URL, baseUrl);
        showStatus('読み込み中...', 'loading');

        try {
            const [modelData, characterData, placeData, actionData, relationshipData, promptData] = await Promise.all([
                fetchGasData(baseUrl, 'model'),
                fetchGasData(baseUrl, 'character'),
                fetchGasData(baseUrl, 'place'),
                fetchGasData(baseUrl, 'action'),
                fetchGasData(baseUrl, 'relationship'),
                fetchGasData(baseUrl, 'llm_prompt_template')
            ]);

            models = parseModels(modelData);
            characters = parseCharacters(characterData);
            places = parsePlaces(placeData);
            actions = parseActionsWithCompositions(actionData);
            relationships = parseRelationships(relationshipData);
            promptTemplates = parsePromptTemplates(promptData);

            saveCachedData();
            updateAllSelects();
            updateTargetSelect();
            updateModelSelect();

            showStatus(`読込完了: ${characters.length}キャラ, ${places.length}場所, ${actions.length}アクション`);
            addSystemMessage(`データ読み込み完了: ${characters.length}キャラ, ${places.length}場所, ${actions.length}アクション`);
        } catch (error) {
            console.error(error);
            showStatus('エラー: ' + error.message, 'error');
        }
    }

    function updateAllSelects() {
        // プルダウン削除済み - ターゲット選択のみ更新
        updateTargetSelect();
    }

    async function executeAction(actionIndex) {
        const action = actions[actionIndex];
        if (!action) return;

        const prevActionIndex = currentState.actionIndex;
        const prevAction = prevActionIndex >= 0 ? actions[prevActionIndex] : null;

        // 状態更新
        currentState.actionIndex = actionIndex;

        // 同じ場所にいるキャラクターのアクションも更新
        const charAtLocation = getCharacterAtUserLocation();
        if (charAtLocation) {
            const statusIndex = characterStatus.findIndex(s => s === charAtLocation.status);
            if (statusIndex >= 0) {
                characterStatus[statusIndex].actionIndex = actionIndex;
                console.log('[アクション実行]', charAtLocation.character.name, 'のアクションを更新:', action.name);
                updateCharacterStatusDisplay();
            }
        }

        // 履歴に追加
        actionHistory.push({
            timestamp: new Date().toISOString(),
            fromAction: prevAction?.action_id || null,
            toAction: action.action_id,
            character: charAtLocation?.character?.name || null,
            place: userState.placeIndex >= 0 ? places[userState.placeIndex]?.name : null
        });

        // ページ生成（アクション実行）
        await generatePages('action_select', action.name, null, null);
    }

    // ========== ページ管理関数 ==========

    // ページを追加（DOM要素を事前作成）
    function addPage(pageData) {
        const pageIndex = pages.length;
        pages.push(pageData);

        // DOM要素を作成
        const pageView = document.getElementById('page-view');
        const pageDiv = document.createElement('div');
        pageDiv.className = 'page-content';
        pageDiv.dataset.pageIndex = pageIndex;
        pageDiv.style.display = 'none';

        let imageHtml = '';
        if (pageData.image) {
            imageHtml = `<img src="${pageData.image}" alt="${pageData.label}">`;
        } else if (pageData.type !== 'system' && pageData.type !== 'dialogue') {
            imageHtml = '<div class="placeholder">画像なし</div>';
        }

        let labelClass = '';
        if (pageData.type === 'character' || pageData.type === 'dialogue') {
            labelClass = 'character';
        }

        const showImage = pageData.type !== 'system' && pageData.type !== 'dialogue';
        pageDiv.innerHTML = `
            ${showImage ? `<div class="page-image">${imageHtml}</div>` : ''}
            <div class="page-text ${pageData.type === 'dialogue' ? 'dialogue-text' : ''}">
                <span class="page-label ${labelClass}">${pageData.label}</span>
                <div>${pageData.text.replace(/\n/g, '<br>')}</div>
            </div>
        `;

        pageView.appendChild(pageDiv);

        updatePageIndicator();

        // 最初のページの場合は表示
        if (pages.length === 1) {
            currentPageIndex = 0;
            showPage(0);
        }
    }

    // 指定インデックスのページを表示（display切り替えのみ）
    function showPage(index) {
        if (index < 0 || index >= pages.length) return;
        currentPageIndex = index;

        // 全ページを非表示にして、指定ページのみ表示
        const pageView = document.getElementById('page-view');
        const pageContents = pageView.querySelectorAll('.page-content');
        pageContents.forEach((el, i) => {
            el.style.display = (i === index) ? 'flex' : 'none';
        });

        updatePageIndicator();
    }

    // 次のページへ
    function nextPage() {
        if (currentPageIndex < pages.length - 1) {
            showPage(currentPageIndex + 1);
        }
    }

    // 前のページへ
    function prevPage() {
        if (currentPageIndex > 0) {
            showPage(currentPageIndex - 1);
        }
    }

    // 最新ページへ
    function goToLatestPage() {
        if (pages.length > 0) {
            showPage(pages.length - 1);
        }
    }

    // ページインジケーター更新
    function updatePageIndicator() {
        const indicator = document.getElementById('page-indicator');
        if (indicator) {
            if (pages.length === 0) {
                indicator.textContent = '-- / --';
            } else {
                indicator.textContent = `${currentPageIndex + 1} / ${pages.length}`;
            }
        }
        // ナビボタンの有効/無効
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        if (prevBtn) prevBtn.disabled = currentPageIndex <= 0;
        if (nextBtn) nextBtn.disabled = currentPageIndex >= pages.length - 1;
    }

    // ========== メッセージ追加関数（システムログはコンソールのみ） ==========

    function addSystemMessage(text) {
        console.log('[System]', text);
    }

    function addStateChangeMessage(text) {
        console.log('[StateChange]', text);
    }

    function addActionMessage(action, label) {
        console.log('[Action]', label, action.name);
    }

    function addTransitionMessage(fromAction, toAction) {
        console.log('[Transition]', fromAction.name, '→', toAction.name);
    }

    function clearChat() {
        pages = [];
        currentPageIndex = -1;
        actionHistory = [];
        chatHistory = [];
        // DOM要素を全削除
        const pageView = document.getElementById('page-view');
        pageView.innerHTML = '';
        updatePageIndicator();
        console.log('[System] チャットをクリアしました');
    }

    // 履歴をコンソールに出力（デバッグ用）
    function dumpHistory() {
        console.log('Action History:', actionHistory);
        return actionHistory;
    }

    // キャラクターステータス表示更新
    function updateCharacterStatusDisplay() {
        for (let i = 0; i < 2; i++) {
            const status = characterStatus[i];
            const num = i + 1;
            const char = status.characterIndex >= 0 ? characters[status.characterIndex] : null;
            const place = status.placeIndex >= 0 ? places[status.placeIndex] : null;
            const action = status.actionIndex >= 0 ? actions[status.actionIndex] : null;
            const relationship = relationships.find(r => r.relationship_id === status.relationshipId);

            document.getElementById(`char${num}-name`).textContent = char ? char.name : '未選択';
            document.getElementById(`char${num}-place`).textContent = place ? place.name : '未選択';
            document.getElementById(`char${num}-action`).textContent = action ? action.name : '未選択';
            document.getElementById(`char${num}-relationship`).textContent = relationship ? relationship.name : '未設定';
            document.getElementById(`char${num}-memo`).textContent = status.memo ? `メモ：${status.memo}` : '';
        }
    }

    // 初期設定開始
    function startInitialSetup() {
        // cast='on' のキャラクターを取得
        const castCharacters = characters
            .map((char, index) => ({ char, index }))
            .filter(item => item.char.cast === 'on');

        if (castCharacters.length < 2) {
            addSystemMessage('cast=onのキャラクターが2人以上必要です。GASから読み込んでください。');
            return;
        }

        // publicな場所を取得
        const publicPlaces = places
            .map((place, index) => ({ place, index }))
            .filter(item => item.place.public_flag === 'public');

        if (publicPlaces.length < 2) {
            addSystemMessage('publicな場所が2つ以上必要です。');
            return;
        }

        // 2人のキャラクターをランダム選択（cast=onから、重複なし）
        const charIndices = [];
        const shuffledCast = [...castCharacters].sort(() => Math.random() - 0.5);
        charIndices.push(shuffledCast[0].index);
        charIndices.push(shuffledCast[1].index);

        // 2つの場所をランダム選択（重複なし）
        const placeIndices = [];
        while (placeIndices.length < 2) {
            const randItem = publicPlaces[Math.floor(Math.random() * publicPlaces.length)];
            if (!placeIndices.includes(randItem.index)) {
                placeIndices.push(randItem.index);
            }
        }

        // ステータスを設定（デフォルトアクションも設定）
        for (let i = 0; i < 2; i++) {
            const place = places[placeIndices[i]];
            // 場所のデフォルトアクションからアクションインデックスを取得
            let actionIndex = -1;
            if (place && place.default_action) {
                actionIndex = actions.findIndex(a => a.action_id === place.default_action);
            }

            characterStatus[i] = {
                characterIndex: charIndices[i],
                placeIndex: placeIndices[i],
                actionIndex: actionIndex,
                relationshipId: 'rel_001',  // 初期値
                memo: ''  // メモ初期値
            };
        }

        // 後方互換: currentStateも更新
        currentState.characterIndex = charIndices[0];
        currentState.placeIndex = placeIndices[0];
        currentState.actionIndex = -1;

        // ユーザーの初期位置を「101号室 玄関」に設定
        const userPlaceIndex = places.findIndex(p => p.name === '101号室 玄関');
        userState.placeIndex = userPlaceIndex >= 0 ? userPlaceIndex : -1;

        updateCharacterStatusDisplay();
        updateUserStatusDisplay();
        updateTargetSelect();

        const char1 = characters[charIndices[0]];
        const char2 = characters[charIndices[1]];
        const place1 = places[placeIndices[0]];
        const place2 = places[placeIndices[1]];
        const action1 = characterStatus[0].actionIndex >= 0 ? actions[characterStatus[0].actionIndex] : null;
        const action2 = characterStatus[1].actionIndex >= 0 ? actions[characterStatus[1].actionIndex] : null;
        const userPlace = userState.placeIndex >= 0 ? places[userState.placeIndex] : null;
        addSystemMessage(`初期設定完了:`);
        addSystemMessage(`  ${char1.name} → ${place1.name} [${action1?.name || 'なし'}]`);
        addSystemMessage(`  ${char2.name} → ${place2.name} [${action2?.name || 'なし'}]`);
        addSystemMessage(`  ユーザー → ${userPlace ? userPlace.name : '未設定'}`);
    }

    // ユーザーステータス表示更新
    function updateUserStatusDisplay() {
        const place = userState.placeIndex >= 0 ? places[userState.placeIndex] : null;
        document.getElementById('user-place').textContent = place ? place.name : '未選択';
    }

    // ユーザーと同じ場所にいるキャラクターを取得
    function getCharacterAtUserLocation() {
        if (userState.placeIndex < 0) return null;
        for (const status of characterStatus) {
            if (status.placeIndex === userState.placeIndex && status.characterIndex >= 0) {
                return {
                    character: characters[status.characterIndex],
                    status: status
                };
            }
        }
        return null;
    }

    // ページ1を追加（説明文 + 場所画像）
    function addPage1(placeImage, text) {
        addPage({
            type: 'narrative',
            image: placeImage,
            text: text,
            label: '状況'
        });
    }

    // ページ2を追加（キャラクターセリフ + アクション画像）
    function addPage2(characterName, image, text) {
        addPage({
            type: 'character',
            image: image,
            text: text,
            label: characterName
        });
    }

    // 会話モード：最後のページがdialogueまたはcharacterなら追記、そうでなければ新規ページ
    function addDialogue(characterName, text) {
        const lastPage = pages[pages.length - 1];

        // 名前があれば「名前 テキスト」、なければテキストのみ
        const lineText = characterName ? `${characterName}${text}` : text;

        // 最後のページがdialogueまたはcharacterタイプなら追記
        if (lastPage && (lastPage.type === 'dialogue' || lastPage.type === 'character')) {
            // データ更新
            lastPage.text += `\n${lineText}`;

            // DOM更新
            const pageView = document.getElementById('page-view');
            const lastPageDiv = pageView.querySelector(`.page-content[data-page-index="${pages.length - 1}"]`);
            if (lastPageDiv) {
                const textDiv = lastPageDiv.querySelector('.page-text > div');
                if (textDiv) {
                    textDiv.innerHTML += `<br>${lineText.replace(/\n/g, '<br>')}`;
                }
            }

            // 最新ページへ移動
            showPage(pages.length - 1);
        } else {
            // 新規ページ作成
            addPage({
                type: 'dialogue',
                image: null,
                text: lineText,
                label: '会話'
            });
            goToLatestPage();
        }
    }

    // ページ生成メイン処理
    // companion: 一緒に移動するキャラクター（移動時のみ使用）
    async function generatePages(actionType, userInput, previousPlace, newPlace, companion = null) {
        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) {
            addSystemMessage('OpenRouter API Keyが必要です');
            return;
        }

        const currentPlace = places[userState.placeIndex];
        // 移動時に一緒に移動した場合はcompanionを使用、それ以外は現在地のキャラクター
        const charAtLocation = companion || getCharacterAtUserLocation();

        // 発言かつキャラクターがいる場合は会話モード
        if (actionType === 'speech' && charAtLocation) {
            // ユーザーの発言を追加
            addDialogue('あなた', `「${userInput}」`);

            const prompt = buildCombinedPrompt(actionType, userInput, null, null, charAtLocation, currentPlace, true);
            console.log('[会話モード] プロンプト:', prompt);

            const response = await callLLM(chatApiKey, prompt, 'character', charAtLocation.character);
            console.log('[会話モード] レスポンス:', response);

            // 関係性変化の判定を抽出
            const { dialogue: parsedDialogue, narrative, newRelationshipName, relationshipMemo } = parseConversationResponse(response, charAtLocation);
            console.log('[会話モード] セリフ:', parsedDialogue, '/ 地の文:', narrative, '/ 新関係性:', newRelationshipName, '/ メモ:', relationshipMemo);

            // 関係性変化の処理 - 名前から検索して更新
            const statusIndex = characterStatus.findIndex(s => s === charAtLocation.status);
            if (statusIndex >= 0) {
                // 関係性変化がある場合
                if (newRelationshipName) {
                    const currentRelationshipId = charAtLocation.status.relationshipId;
                    const currentRelationship = relationships.find(r => r.relationship_id === currentRelationshipId);
                    // 名前で関係性を検索
                    const newRelationship = relationships.find(r => r.name === newRelationshipName);
                    if (newRelationship && newRelationship.relationship_id !== currentRelationshipId) {
                        characterStatus[statusIndex].relationshipId = newRelationship.relationship_id;
                        console.log('[関係性変化]', charAtLocation.character.name, ':', currentRelationship?.name, '→', newRelationship.name);
                        addSystemMessage(`💫 ${charAtLocation.character.name}との関係性が「${currentRelationship?.name || '不明'}」から「${newRelationship.name}」に変化しました`);
                    }
                }
                // メモがあれば保存（関係性変化がなくても）
                if (relationshipMemo) {
                    characterStatus[statusIndex].memo = relationshipMemo;
                    console.log('[メモ更新]', charAtLocation.character.name, ':', relationshipMemo);
                }
                updateCharacterStatusDisplay();
            }

            addDialogue(charAtLocation.character.name, parsedDialogue);
            // 地の文があれば追加
            if (narrative) {
                addDialogue('', narrative);
            }
            return;
        }

        // 発言だがキャラクターがいない場合
        if (actionType === 'speech' && !charAtLocation) {
            addSystemMessage('この場所には誰もいません');
            return;
        }

        // 通常モード：ページ1 + ページ2を1回のLLM呼び出しで取得
        const combinedPrompt = buildCombinedPrompt(actionType, userInput, previousPlace, newPlace, charAtLocation, currentPlace, false, companion);
        console.log('[Combined] プロンプト:', combinedPrompt);

        const response = await callLLM(chatApiKey, combinedPrompt, 'combined');
        console.log('[LLM] レスポンス:', response);
        const { narrative, dialogue, newRelationshipName, relationshipMemo } = parseCombinedResponse(response, charAtLocation);
        console.log('[LLM] パース結果 - 地の文:', narrative, '/ セリフ:', dialogue, '/ 新関係性:', newRelationshipName, '/ メモ:', relationshipMemo);

        // 関係性変化の処理 - 名前から検索して更新
        if (charAtLocation) {
            const statusIndex = characterStatus.findIndex(s => s === charAtLocation.status);
            if (statusIndex >= 0) {
                // 関係性変化がある場合
                if (newRelationshipName) {
                    const currentRelationshipId = charAtLocation.status.relationshipId;
                    const currentRelationship = relationships.find(r => r.relationship_id === currentRelationshipId);
                    // 名前で関係性を検索
                    const newRelationship = relationships.find(r => r.name === newRelationshipName);
                    if (newRelationship && newRelationship.relationship_id !== currentRelationshipId) {
                        characterStatus[statusIndex].relationshipId = newRelationship.relationship_id;
                        console.log('[関係性変化]', charAtLocation.character.name, ':', currentRelationship?.name, '→', newRelationship.name);
                        addSystemMessage(`💫 ${charAtLocation.character.name}との関係性が「${currentRelationship?.name || '不明'}」から「${newRelationship.name}」に変化しました`);
                    }
                }
                // メモがあれば保存（関係性変化がなくても）
                if (relationshipMemo) {
                    characterStatus[statusIndex].memo = relationshipMemo;
                    console.log('[メモ更新]', charAtLocation.character.name, ':', relationshipMemo);
                }
                updateCharacterStatusDisplay();
            }
        }

        // 同じ場所でのアクション（action_select/action_with_speech）は地の文を最後のページに追加
        const isSameLocationAction = actionType === 'action_select' || actionType === 'action_with_speech';
        const placeImage = currentPlace?.image || null;

        if (isSameLocationAction && pages.length > 0) {
            // 最後のページに地の文を追記
            addDialogue('', narrative);
        } else {
            // 新しいページを作成（移動時など）
            addPage1(placeImage, narrative);
        }

        // ページ2: キャラクターがいる場合のみ
        if (charAtLocation && dialogue) {
            // 画像生成（On/Offチェック）
            let charImage = null;
            if (imageGenEnabled) {
                const runwareApiKey = document.getElementById('runwareApiKey').value.trim();
                if (runwareApiKey) {
                    localStorage.setItem(RUNWARE_API_KEY, runwareApiKey);
                    try {
                        // キャラクターのアクションインデックスを使用
                        const charActionIndex = charAtLocation.status?.actionIndex ?? -1;
                        charImage = await generateCharacterImage(charAtLocation.character, currentPlace, charActionIndex);
                    } catch (e) {
                        console.error('[画像生成エラー]', e);
                    }
                }
            }

            addPage2(charAtLocation.character.name, charImage, dialogue);
        }
    }

    // 統合プロンプト構築
    // dialogueOnly: true の場合はセリフのみ要求（会話モード）
    // companion: 一緒に移動したキャラクター（移動時のみ）
    function buildCombinedPrompt(actionType, userInput, previousPlace, newPlace, charAtLocation, currentPlace, dialogueOnly = false, companion = null) {
        // 会話モード
        if (dialogueOnly && charAtLocation) {
            const charName = charAtLocation.character.name;
            const char = charAtLocation.character;
            let prompt = '';

            // キャラクター情報
            prompt += `【会話相手】${charName}`;
            if (char.series) prompt += `（${char.series}）`;
            if (char.profile) prompt += `\nプロフィール: ${char.profile}`;

            // 関係性情報
            const relationshipId = charAtLocation.status?.relationshipId;
            let relationship = null;
            if (relationshipId) {
                relationship = relationships.find(r => r.relationship_id === relationshipId);
                if (relationship) {
                    prompt += `\n現在の関係性: ${relationship.name}（${relationship.description || ''}）`;
                    // メモがあれば追加
                    if (charAtLocation.status?.memo) {
                        prompt += `\n関係性メモ: ${charAtLocation.status.memo}`;
                    }
                    // 進展条件があれば追加
                    if (relationship.next_relationship_req) {
                        prompt += `\n関係性進展条件: ${relationship.next_relationship_req}`;
                    }
                }
            }

            prompt += `\n\n主人公「${userInput}」\n`;

            // 出力フォーマット
            const dialogueInstruction = getPromptTemplate(promptTemplates, 'llm_003', { name: charName })
                || `【${charName}のセリフ】「」付きで1-2文で出力`;

            prompt += `\n${dialogueInstruction}`;
            prompt += `\n【地の文】必要な場合のみ、セリフの後の状況や動作を1行で記載（不要なら省略）`;

            // 関係性進展条件がある場合のみ判定を追加
            if (relationship && relationship.next_relationship_req) {
                prompt += `\n【関係性変化】この会話で関係性進展条件を満たした場合、もしくは総合的に関係性変化が起きたと判断される場合は新しい関係性名を記載、満たしていない場合は「維持」と記載`;
                prompt += `\n【関係性メモ】関係性が変化した場合は必ず記載。変化がなくてもメモ更新が必要な出来事があれば記載。キャラクター視点で50文字以内でどこで何が起きて、なぜその関係性になったのか、今後どうしていきたいか、キャラクターの感情を交えて記載。不要なら省略`;
            }

            return prompt;
        }

        let prompt = '';

        // 状況説明（日本語）
        let situationText = '';
        if (actionType === 'action_select' && currentState.actionIndex >= 0) {
            const action = actions[currentState.actionIndex];
            situationText = action?.name || '';
        } else if (actionType === 'action_with_speech' && currentState.actionIndex >= 0) {
            const action = actions[currentState.actionIndex];
            situationText = `${action?.name || ''} + 主人公の発言「${userInput}」`;
        } else if (actionType === 'action' || actionType === 'scenario') {
            situationText = userInput;
        } else if (actionType === 'move') {
            // 移動時専用テンプレート（llm_006）を使用
            const moveTemplate = getPromptTemplate(promptTemplates, 'llm_006', {
                from: previousPlace?.name || '',
                to: newPlace?.name || ''
            });
            console.log('[移動] from:', previousPlace?.name, 'to:', newPlace?.name, 'template:', moveTemplate);
            situationText = moveTemplate || `${previousPlace?.name || ''}から${newPlace?.name || ''}に移動`;

            // 一緒に移動した場合のみ、関係性をチェック
            if (companion) {
                const relId = companion.status?.relationshipId || '';
                const relNumMatch = relId.match(/^rel_(\d+)$/);
                if (relNumMatch) {
                    const relNum = parseInt(relNumMatch[1], 10);
                    if (relNum < 100) {
                        situationText += `（${companion.character.name}を無理やり連れて行った）`;
                        console.log('[移動] 関係性', relId, '< rel_100 → 無理やり連れて行った');
                    }
                }
            }
        } else if (actionType === 'speech') {
            situationText = `主人公の発言「${userInput}」`;
        }

        // 画像プロンプト（タグ）
        const imageParts = [];
        if (charAtLocation?.character?.tag) {
            imageParts.push(charAtLocation.character.tag);
        }
        if (currentPlace?.tag) {
            imageParts.push(currentPlace.tag);
        }
        // ユーザーのアクション（action_select/action_with_speech時）
        if ((actionType === 'action_select' || actionType === 'action_with_speech') && currentState.actionIndex >= 0) {
            const action = actions[currentState.actionIndex];
            if (action?.prompt) imageParts.push(action.prompt);
            const compositionTag = getCompositionTag(actions, currentState.actionIndex);
            console.log('[LLMプロンプト] ユーザーアクション:', action?.name, '構図:', compositionTag || '(なし)');
            if (compositionTag) imageParts.push(compositionTag);
        }
        // キャラクターのアクション（移動時など）
        const charActionIndex = charAtLocation?.status?.actionIndex ?? -1;
        if (charActionIndex >= 0 && actions[charActionIndex]) {
            const charAction = actions[charActionIndex];
            if (charAction?.prompt) imageParts.push(charAction.prompt);
            const charCompositionTag = getCompositionTag(actions, charActionIndex);
            console.log('[LLMプロンプト] キャラアクション:', charAction?.name, '構図:', charCompositionTag || '(なし)');
            if (charCompositionTag) imageParts.push(charCompositionTag);
        }
        if (currentPlace?.additionalTag) {
            imageParts.push(currentPlace.additionalTag);
        }
        if (charAtLocation?.character?.additionalTag) {
            imageParts.push(charAtLocation.character.additionalTag);
        }

        prompt += `状況：${situationText}\n`;
        prompt += `画像プロンプト：${imageParts.filter(p => p).join(', ')}\n`;

        if (charAtLocation) {
            const char = charAtLocation.character;
            prompt += `\n【その場にいる人物】${char.name}`;
            if (char.series) prompt += `（${char.series}）`;
            if (char.profile) prompt += `\nプロフィール: ${char.profile}`;
            // 関係性情報を追加
            const relationshipId = charAtLocation.status?.relationshipId;
            if (relationshipId) {
                const relationship = relationships.find(r => r.relationship_id === relationshipId);
                if (relationship) {
                    prompt += `\n現在の関係性: ${relationship.name}（${relationship.description || ''}）`;
                    // メモがあれば追加
                    if (charAtLocation.status?.memo) {
                        prompt += `\n関係性メモ: ${charAtLocation.status.memo}`;
                    }
                    // 進展条件があれば追加
                    if (relationship.next_relationship_req) {
                        prompt += `\n関係性進展条件: ${relationship.next_relationship_req}`;
                    }
                }
            }
            // キャラクターのアクション情報を追加
            const charActionIndex = charAtLocation.status?.actionIndex ?? -1;
            if (charActionIndex >= 0 && actions[charActionIndex]) {
                const charAction = actions[charActionIndex];
                prompt += `\n現在の行動: ${charAction.name}`;
                if (charAction.prompt) prompt += `（${charAction.prompt}）`;
            }
            prompt += '\n';
        }

        // 通常モード：地の文 + セリフ + 関係性変化（テンプレートから取得）
        const charName = charAtLocation?.character?.name || '';
        let formatPrompt = getPromptTemplate(promptTemplates, 'llm_004', { name: charName })
            || `以下の形式で出力してください：\n【地の文】（2-3文で状況を描写）\n${charName ? `【${charName}のセリフ】（「」付きで1-2文）` : ''}`;

        // 関係性進展条件がある場合のみ判定を追加
        if (charAtLocation) {
            const relationshipId = charAtLocation.status?.relationshipId;
            const relationship = relationships.find(r => r.relationship_id === relationshipId);
            if (relationship && relationship.next_relationship_req) {
                formatPrompt += `\n【関係性変化】このシーンで関係性進展条件を満たした場合、もしくは総合的に関係性変化が起きたと判断される場合は新しい関係性名を記載、満たしていない場合は「維持」と記載`;
                formatPrompt += `\n【関係性メモ】関係性が変化した場合は必ず記載。変化がなくてもメモ更新が必要な出来事があれば記載。キャラクター視点で50文字以内でどこで何が起きて、なぜその関係性になったのか、今後どうしていきたいか、キャラクターの感情を交えて記載。不要なら省略`;
            }
        }

        prompt += `\n${formatPrompt}`;

        return prompt;
    }

    // 統合レスポンスをパース
    function parseCombinedResponse(response, charAtLocation) {
        let narrative = '';
        let dialogue = '';
        let newRelationshipName = null;
        let relationshipMemo = null;

        // 【地の文】セクションを抽出
        const narrativeMatch = response.match(/【地の文】\s*([\s\S]*?)(?=【|$)/);
        if (narrativeMatch) {
            narrative = narrativeMatch[1].trim();
        } else {
            // フォーマットが異なる場合は全体を地の文として扱う
            narrative = response.trim();
        }

        // キャラクターがいる場合、セリフセクションを抽出
        if (charAtLocation) {
            const charName = charAtLocation.character.name;
            const dialogueRegex = new RegExp(`【${charName}のセリフ】\\s*([\\s\\S]*?)(?=【|$)`);
            const dialogueMatch = response.match(dialogueRegex);
            if (dialogueMatch) {
                dialogue = dialogueMatch[1].trim();
            }
        }

        // 【関係性変化】セクションを抽出 - 関係性名を取得
        const relationshipMatch = response.match(/【関係性変化】\s*([\s\S]*?)(?=【|$)/);
        if (relationshipMatch) {
            const result = relationshipMatch[1].trim();
            // 「維持」以外の場合は関係性名として扱う
            if (!result.includes('維持')) {
                newRelationshipName = result;
            }
        }

        // 【関係性メモ】セクションを抽出
        const memoMatch = response.match(/【関係性メモ】\s*([\s\S]*?)(?=【|$)/);
        if (memoMatch) {
            // 「（〇〇文字）」などの余計なテキストを除去
            relationshipMemo = memoMatch[1].trim().replace(/[（(]\d+文字[）)]/g, '').trim();
        }

        return { narrative, dialogue, newRelationshipName, relationshipMemo };
    }

    // 会話モードレスポンスをパース
    function parseConversationResponse(response, charAtLocation) {
        let dialogue = '';
        let narrative = '';
        let newRelationshipName = null;
        let relationshipMemo = null;

        // 【キャラ名のセリフ】セクションを抽出
        if (charAtLocation) {
            const charName = charAtLocation.character.name;
            const dialogueRegex = new RegExp(`【${charName}のセリフ】\\s*([\\s\\S]*?)(?=【|$)`);
            const dialogueMatch = response.match(dialogueRegex);
            if (dialogueMatch) {
                dialogue = dialogueMatch[1].trim();
            } else {
                // フォーマットが異なる場合、【地の文】または【関係性変化】より前の部分をセリフとして扱う
                const beforeNarrative = response.split(/【地の文】|【関係性変化】/)[0].trim();
                dialogue = beforeNarrative;
            }
            // セリフから【地の文】以降を除去
            dialogue = dialogue.split(/【地の文】|【関係性変化】|【関係性メモ】/)[0].trim();
        }

        // 【地の文】セクションを抽出（最初の1行のみ）
        const narrativeMatch = response.match(/【地の文】\s*([\s\S]*?)(?=【|$)/);
        if (narrativeMatch) {
            const lines = narrativeMatch[1].trim().split('\n').filter(l => l.trim());
            narrative = lines[0] || '';
        }

        // 【関係性変化】セクションを抽出 - 関係性名を取得
        const relationshipMatch = response.match(/【関係性変化】\s*([\s\S]*?)(?=【|$)/);
        if (relationshipMatch) {
            const result = relationshipMatch[1].trim();
            // 「維持」以外の場合は関係性名として扱う
            if (!result.includes('維持')) {
                newRelationshipName = result;
            }
        }

        // 【関係性メモ】セクションを抽出
        const memoMatch = response.match(/【関係性メモ】\s*([\s\S]*?)(?=【|$)/);
        if (memoMatch) {
            // 「（〇〇文字）」などの余計なテキストを除去
            relationshipMemo = memoMatch[1].trim().replace(/[（(]\d+文字[）)]/g, '').trim();
        }

        return { dialogue, narrative, newRelationshipName, relationshipMemo };
    }

    // 構図タグ取得（共通関数を使用）
    // selectBestComposition, getCompositionTag は js/prompt-utils.js で定義

    // キャラクター画像生成（image_gen_base.htmlと同じ方式）
    async function generateCharacterImage(character, place, actionIndex) {
        const runwareApiKey = document.getElementById('runwareApiKey').value.trim();
        if (!runwareApiKey) return null;

        // モデル取得（選択されたモデルを優先、なければ最初のモデル）
        const modelId = selectedModelId || getFirstModelId(models);
        if (!modelId || !models[modelId]) {
            console.log('[画像生成] モデルが未設定');
            return null;
        }
        const model = models[modelId];

        // 構図タグを取得（BESTから選択）
        const compositionTag = getCompositionTag(actions, actionIndex);

        // プロンプト構築（image_gen_base.htmlと同じ順序）
        const parts = [
            model?.qualityPositive || '',           // 品質タグ（ポジティブ）
            character?.tag || '',                    // キャラタグ
            place?.tag || '',                        // 場所タグ
            (actionIndex >= 0 && actions[actionIndex]) ? actions[actionIndex].prompt : '',  // アクションプロンプト
            compositionTag,                          // 構図タグ（BEST選択）
            place?.additionalTag || '',              // 場所の追加タグ
            character?.additionalTag || ''           // キャラの追加タグ
        ].filter(p => p);

        if (parts.length === 0) {
            console.log('[画像生成] プロンプトが空のためスキップ');
            return null;
        }

        const prompt = cleanPrompt(parts.join(', '));
        const negativePrompt = model?.qualityNegative || '';

        console.log('[画像生成] モデル:', modelId);
        console.log('[画像生成] 構図:', compositionTag || '(なし)');
        console.log('[画像生成] プロンプト:', prompt);
        console.log('[画像生成] ネガティブ:', negativePrompt);

        const result = await generateImage(runwareApiKey, modelId, prompt, {
            negativePrompt: negativePrompt,
            steps: model?.steps || 20,
            cfgScale: model?.cfgScale || 7,
            scheduler: model?.scheduler || 'Default',
            width: 1024,
            height: 1024,
            character: character
        });

        return result.imageURL;
    }

    // ページ1用プロンプト構築
    function buildPage1Prompt(actionType, userInput, previousPlace, newPlace, charAtLocation) {
        const narratorPrompt = getPromptTemplate(promptTemplates, 'llm_005')
            || 'あなたは小説の地の文を書くナレーターです。簡潔に2-3文で状況を描写してください。';
        let prompt = narratorPrompt + '\n\n';

        const currentPlace = places[userState.placeIndex];
        prompt += `【現在の場所】${currentPlace?.name || '不明'}\n`;

        if (charAtLocation) {
            prompt += `【その場にいる人物】${charAtLocation.character.name}`;
            // 関係性情報を追加
            const relationshipId = charAtLocation.status?.relationshipId;
            if (relationshipId) {
                const relationship = relationships.find(r => r.relationship_id === relationshipId);
                if (relationship) {
                    prompt += `（関係性: ${relationship.name}`;
                    if (relationship.description) prompt += ` - ${relationship.description}`;
                    prompt += `）`;
                }
            }
            prompt += '\n';
        }

        switch (actionType) {
            case 'move':
                prompt += `【状況】主人公が「${previousPlace?.name || ''}」から「${newPlace?.name || ''}」に移動した。\n`;
                break;
            case 'speech':
                prompt += `【状況】主人公が「${userInput}」と言った。\n`;
                break;
            case 'action':
                prompt += `【状況】主人公が「${userInput}」という行為をした。\n`;
                break;
            case 'action_select':
                prompt += `【状況】主人公が「${userInput}」を行った。\n`;
                break;
            case 'action_with_speech':
                const actionName = actions[currentState.actionIndex]?.name || '';
                prompt += `【状況】主人公が「${actionName}」をしながら「${userInput}」と言った。\n`;
                break;
            case 'scenario':
                prompt += `【状況】${userInput}\n`;
                break;
        }

        prompt += '\n地の文のみを出力してください。';
        return prompt;
    }

    // LLM呼び出し（履歴付き）
    async function callLLM(apiKey, prompt, role, character = null) {
        // システムプロンプト（テンプレートから取得、なければデフォルト）
        const systemPrompt = getPromptTemplate(promptTemplates, 'llm_001')
            || 'あなたは小説のシーンを描写するアシスタントです。指定された形式で簡潔に出力してください。';

        // メッセージ構築（履歴 + 新しいプロンプト）
        const messages = [
            { role: 'system', content: systemPrompt },
            ...chatHistory,
            { role: 'user', content: prompt }
        ];

        console.log('[LLM] 履歴数:', chatHistory.length / 2, '往復');

        // GASにリクエストログを送信（非同期、レスポンスを待たない）
        const gasUrl = document.getElementById('gasUrl').value.trim();
        if (gasUrl) {
            const logData = [];
            // JSON構造を反映したログ形式（log_key, log_value）
            logData.push({ log_key: 'model', log_value: 'x-ai/grok-4.1-fast' });
            messages.forEach((msg, i) => {
                logData.push({ log_key: `messages[${i}].role`, log_value: msg.role });
                logData.push({ log_key: `messages[${i}].content`, log_value: msg.content });
            });
            // 非同期で送信（await しない）
            console.log('[GAS Log] 送信データ:', logData);
            saveGasData(gasUrl, 'llm_req_log', logData)
                .then(res => console.log('[GAS Log] 送信結果:', res))
                .catch(e => console.error('[GAS Log Error]', e));
        }

        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'x-ai/grok-4.1-fast',
                    messages: messages
                })
            });

            if (!response.ok) {
                const error = await response.json();
                console.error('[LLM] エラー:', error);
                return 'エラーが発生しました';
            }

            const data = await response.json();
            const content = data.choices?.[0]?.message?.content || '応答なし';

            // 履歴に追加（最大10往復 = 20メッセージ）
            chatHistory.push({ role: 'user', content: prompt });
            chatHistory.push({ role: 'assistant', content: content });

            // 履歴が多すぎる場合は古いものを削除
            while (chatHistory.length > 20) {
                chatHistory.shift();
                chatHistory.shift();
            }

            return content;
        } catch (error) {
            console.error('[LLM] 通信エラー:', error);
            return '通信エラーが発生しました';
        }
    }
</script>

</body>
</html>
