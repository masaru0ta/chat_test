<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, interactive-widget=resizes-content">
    <title>Transition Test</title>
    <link rel="stylesheet" href="css/common.css">
    <style>
        html, body {
            padding: 0;
            margin: 0;
            overflow: hidden;
            height: 100%;
            height: 100dvh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: 100vh;
            height: 100dvh;
            transition: grid-template-columns 0.3s ease;
        }

        .app-container.sidebar-collapsed {
            grid-template-columns: 0 1fr;
        }

        /* サイドバー */
        .sidebar {
            background: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .sidebar-collapsed .sidebar {
            transform: translateX(-100%);
            opacity: 0;
        }

        /* サイドバートグルボタン */
        .sidebar-toggle {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: #333;
            border: 1px solid #444;
            color: #fff;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: left 0.3s ease, background 0.2s;
        }

        .sidebar-toggle:hover {
            background: #4a9eff;
        }

        .app-container:not(.sidebar-collapsed) .sidebar-toggle {
            left: 310px;
        }

        .sidebar-header {
            padding: 15px;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .sidebar-header h2 {
            margin: 0;
            color: #4a9eff;
            font-size: 1rem;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            overscroll-behavior: contain;
            padding: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.9rem;
        }

        .current-state {
            background: #222;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .current-state h3 {
            margin: 0 0 10px 0;
            color: #4a9eff;
            font-size: 0.9rem;
        }

        .state-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 0.85rem;
        }

        .state-item:last-child {
            border-bottom: none;
        }

        .state-label {
            color: #888;
        }

        .state-value {
            color: #fff;
            text-align: right;
            max-width: 150px;
        }

        .memo-line {
            font-size: 0.8rem;
            color: #aaa;
            padding: 3px 0;
        }

        .place-btn {
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 2px 8px;
        }

        .place-btn:hover {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .sidebar-footer {
            padding: 15px;
            background: #222;
            border-top: 1px solid #333;
        }

        .sidebar-footer input {
            width: 100%;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        /* チャットエリア */
        .chat-area {
            display: flex;
            flex-direction: column;
            background: #000;
            overflow: hidden;
        }

        .chat-header {
            padding: 10px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* ページ表示エリア（固定表示） */
        .page-area {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: #000;
        }

        #page-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #000;
            overflow: hidden;
            position: relative;
        }

        .page-status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }

        .page-status-prev {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }

        .page-status-prev-btn {
            background: #555;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .page-status-prev-btn:hover {
            background: #666;
        }

        .page-status-loading {
            background: rgba(0, 0, 0, 0.7);
            color: #aaa;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.9rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .page-status-next {
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .page-status-next:hover {
            background: #3a8eef;
        }

        .page-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .page-image {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .page-image .placeholder {
            color: #666;
            font-size: 0.9rem;
        }

        .page-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            line-height: 1.8;
            font-size: 1rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.6);
            max-height: 100%;
            overflow-y: auto;
        }

        .page-text.system-text {
            position: static;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #888;
            height: 100%;
            max-height: none;
            background: #000;
        }

        /* 画像なしのページ（dialogue等）*/
        .page-content:not(:has(.page-image)) .page-text {
            position: static;
            height: 100%;
            max-height: none;
            background: #000;
        }

        .page-label {
            background: #4a9eff;
            color: #fff;
            padding: 4px 12px;
            font-size: 0.8rem;
            display: inline-block;
            margin-bottom: 12px;
            border-radius: 4px;
        }

        .page-label.character {
            background: #e53e3e;
        }

        .page-label.system {
            background: #555;
        }

        /* ページナビゲーション */
        .page-nav {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .page-nav button {
            padding: 6px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-nav button:hover:not(:disabled) {
            background: #3a3a3a;
            border-color: #4a9eff;
        }

        .page-nav button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #page-indicator {
            color: #888;
            font-size: 0.85rem;
            min-width: 50px;
            text-align: center;
        }

        .page-nav .latest-btn {
            font-size: 0.75rem;
            padding: 5px 10px;
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .page-nav .latest-btn:hover:not(:disabled) {
            background: #3a8eef;
        }

        .action-name {
            font-weight: bold;
            color: #90cdf4;
            margin-bottom: 5px;
        }

        .action-prompt {
            font-size: 0.85rem;
            color: #a0aec0;
        }

        .transition-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .transition-arrow {
            color: #4a9eff;
            font-size: 1.2rem;
        }

        /* コマンド入力エリア */
        .command-area {
            padding: 12px 20px;
            background: #1a1a1a;
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            gap: 10px;
        }

        .command-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .command-type-buttons {
            display: flex;
            gap: 4px;
        }

        .command-type-btn {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a2a;
            color: #888;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .command-type-btn:hover {
            background: #3a3a3a;
            border-color: #4a9eff;
        }

        .command-type-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: #fff;
        }

        #command-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.9rem;
        }

        #command-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .command-execute-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #4a9eff;
            color: #fff;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .command-execute-btn:hover {
            background: #3a8eef;
        }

        .command-target-select {
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.85rem;
            min-width: 150px;
        }

        .command-target-select:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .action-btn.current {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        #status {
            font-size: 0.8rem;
            margin-top: 8px;
        }

        /* 設定モーダル */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            width: 400px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .settings-header h3 {
            margin: 0;
            color: #4a9eff;
        }

        .settings-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .settings-close:hover {
            color: #fff;
        }

        .settings-group {
            margin-bottom: 15px;
        }

        .settings-group label {
            display: block;
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .settings-group input,
        .settings-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #2a2a2a;
            color: #fff;
            font-size: 0.85rem;
            box-sizing: border-box;
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-row input {
            flex: 1;
        }

        @media (max-width: 768px) {
            html, body {
                height: 100%;
                height: -webkit-fill-available;
            }
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                height: 100%;
                height: -webkit-fill-available;
                min-height: -webkit-fill-available;
            }
            .app-container.sidebar-collapsed {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr;
            }
            .sidebar {
                border-right: none;
                border-bottom: 1px solid #333;
                max-height: 30vh;
                overflow-y: auto;
            }
            .sidebar-collapsed .sidebar {
                display: none;
            }
            .chat-area {
                min-height: 0;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                padding-bottom: 100px;
            }
            .page-area {
                flex: 1;
                min-height: 50px;
                overflow: hidden;
            }
            .command-area {
                position: fixed;
                bottom: 0;
                bottom: env(safe-area-inset-bottom, 0);
                left: 0;
                right: 0;
                padding: 8px 10px;
                padding-bottom: calc(8px + env(safe-area-inset-bottom, 0));
                background: #1a1a1a;
                border-top: 1px solid #333;
                z-index: 9999;
            }
            .command-row {
                gap: 5px;
            }
            #command-input {
                min-width: 0;
            }
        }
    </style>
</head>
<body>

<div class="app-container" id="appContainer">
    <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()" title="サイドバー開閉">☰</button>
    <!-- サイドバー -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>Transition Test</h2>
        </div>
        <div class="sidebar-content">
            <!-- キャラクターステータス（動的生成） -->
            <div id="characters-container"></div>

            <!-- ユーザーステータス -->
            <div class="current-state">
                <h3>ユーザー</h3>
                <div class="state-item">
                    <span class="state-label">現在地</span>
                    <span class="state-value" id="user-place">未選択</span>
                </div>
            </div>

            <button class="btn btn-primary" onclick="startInitialSetup()" style="width:100%; margin-bottom:10px;">初期設定</button>
            <button class="btn" onclick="openSettings()" style="width:100%; background:#333; color:#fff; border:1px solid #444; padding:10px; border-radius:4px; cursor:pointer;">設定</button>
        </div>
    </div>

    <!-- 設定モーダル -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h3>設定</h3>
                <button class="settings-close" onclick="closeSettings()">&times;</button>
            </div>
            <div class="settings-group">
                <label>GAS URL</label>
                <div class="settings-row">
                    <input type="text" id="gasUrl" placeholder="GAS URL">
                    <button class="btn" id="llmLogToggle" onclick="toggleLLMLog()" style="padding:8px 12px; font-size:0.8rem;" title="LLMログ保存">OFF</button>
                </div>
            </div>
            <button class="btn btn-primary" onclick="loadAllFromGas()" style="width:100%; margin-bottom:15px;">GAS読み込み</button>
            <div class="settings-group">
                <label>OpenRouter API Key</label>
                <input type="password" id="chatApiKey" placeholder="OpenRouter API Key" onchange="saveChatApiKey()">
            </div>
            <div class="settings-group">
                <label>Runware API Key</label>
                <div class="settings-row">
                    <input type="password" id="runwareApiKey" placeholder="Runware API Key" onchange="saveRunwareApiKey()">
                    <button class="btn" id="imageGenToggle" onclick="toggleImageGen()" style="padding:8px 12px; font-size:0.8rem;">ON</button>
                </div>
            </div>
            <div class="settings-group">
                <label>LLMモデル</label>
                <select id="llmModelSelect" onchange="onLLMModelSelect()">
                    <option value="x-ai/grok-4.1-fast">Grok 4.1 Fast</option>
                    <option value="x-ai/grok-4-fast">Grok 4 Fast</option>
                </select>
            </div>
            <div class="settings-group">
                <label>画像モデル</label>
                <select id="modelSelect" onchange="onModelSelect()">
                    <option value="">-- 画像モデル選択 --</option>
                </select>
            </div>
            <div class="settings-group">
                <label>登場人数</label>
                <input type="number" id="characterCountInput" min="1" max="10" value="2" onchange="onCharacterCountChange()" style="width:80px;">
            </div>
            <div id="status"></div>
        </div>
    </div>

    <!-- チャットエリア -->
    <div class="chat-area">
        <div class="chat-header">
            <div class="page-nav">
                <button id="prev-page-btn" onclick="prevPage()" disabled>&lt;</button>
                <span id="page-indicator">-- / --</span>
                <button id="next-page-btn" onclick="nextPage()" disabled>&gt;</button>
                <button class="latest-btn" onclick="goToLatestPage()">最新</button>
            </div>
        </div>
        <div class="page-area">
            <div id="page-view">
                <div class="page-status-prev" id="page-status-prev" style="display:none;"></div>
                <div class="page-status" id="page-status" style="display:none;"></div>
            </div>
        </div>
        <div class="command-area">
            <div class="command-row">
                <button class="command-type-btn active" onclick="toggleTargetType()" id="target-toggle">移動</button>
                <select class="command-target-select" id="target-select" onchange="onTargetSelect()">
                    <option value="">-- 選択 --</option>
                </select>
                <button class="command-type-btn" onclick="toggleMoveMode()" id="move-mode-toggle">一人で</button>
            </div>
            <div class="command-row">
                <button class="command-type-btn active" onclick="toggleCommandType()" id="cmd-toggle">発言</button>
                <input type="text" id="command-input" placeholder="発言内容を入力..." onkeydown="if(event.key==='Enter')executeCommand()">
                <button class="command-execute-btn" onclick="executeCommand()">実行</button>
            </div>
        </div>
    </div>
</div>

<script src="js/constants.js"></script>
<script src="js/gas-api.js"></script>
<script src="js/storage.js"></script>
<script src="js/data-parser.js"></script>
<script src="js/ui-utils.js"></script>
<script src="js/prompt-utils.js"></script>
<script src="js/runware-api.js"></script>
<script>
    const CACHE_KEY = 'transition_test_cache';

    // データストア
    let models = {};
    let characters = [];
    let places = [];
    let actions = [];
    let relationships = [];  // 関係性データ
    let transitions = [];  // 遷移データ（将来用）
    let promptTemplates = {};  // LLMプロンプトテンプレート

    // 現在の状態（後方互換用）
    let currentState = {
        characterIndex: -1,
        placeIndex: -1,
        actionIndex: -1
    };

    // ユーザーステータス
    let userState = {
        placeIndex: -1
    };

    // キャラクターステータス（2人分）
    let characterStatus = [
        {
            characterIndex: -1,
            placeIndex: -1,
            actionIndex: -1,   // 現在のアクション
            relationshipId: 'rel_001',  // 関係性ID
            memo: ''  // メモ
        },
        {
            characterIndex: -1,
            placeIndex: -1,
            actionIndex: -1,
            relationshipId: 'rel_001',
            memo: ''
        }
    ];

    // コマンドタイプ
    let currentCommandType = 'speech';

    // ターゲットタイプ（移動/アクション）
    let currentTargetType = 'move';

    // チャット履歴
    let chatHistory = [];

    // 履歴
    let actionHistory = [];

    // ページ履歴（ページ単位表示用）
    let pages = [];
    let currentPageIndex = -1;

    // 登場人数
    let characterCount = 2;
    const CHARACTER_COUNT_KEY = 'transition_character_count';

    // ストレージキー
    const CHAT_API_KEY = 'transition_chat_api_key';
    const RUNWARE_API_KEY = 'transition_runware_api_key';
    const IMAGE_GEN_ENABLED_KEY = 'transition_image_gen_enabled';

    // 画像生成On/Off
    let imageGenEnabled = true;

    // LLMログ保存On/Off
    let llmLogEnabled = false;
    const LLM_LOG_ENABLED_KEY = 'transition_llm_log_enabled';

    // 選択中のモデルID（画像生成用）
    let selectedModelId = '';
    const SELECTED_MODEL_KEY = 'transition_selected_model';

    // LLMモデル選択
    const LLM_MODELS = {
        'x-ai/grok-4.1-fast': { name: 'Grok 4.1 Fast' },
        'x-ai/grok-4-fast': { name: 'Grok 4 Fast' }
    };
    let selectedLLMModelId = 'x-ai/grok-4.1-fast';
    const SELECTED_LLM_MODEL_KEY = 'transition_selected_llm_model';

    // 移動モード（一人で/一緒に）
    let moveWithCompanion = false;

    // 読み込み状態
    let isLoading = false;

    // タイプライター表示用
    let typewriterBuffer = '';      // 表示待ちテキスト
    let typewriterDisplayed = '';   // 表示済みテキスト
    let typewriterTimer = null;     // タイマーID
    let typewriterPageIndex = -1;   // 表示先ページ
    const TYPEWRITER_SPEED = 45;    // 1文字あたりのミリ秒

    // 読み込み中表示
    function showLoading() {
        isLoading = true;
        const statusEl = document.getElementById('page-status');
        if (statusEl) {
            statusEl.innerHTML = '<span class="page-status-loading">読込中...</span>';
            statusEl.style.display = 'block';
        }
    }

    // 読み込み完了・ステータス更新
    function hideLoading() {
        isLoading = false;
        updatePageStatus();
    }

    // タイプライター開始
    function startTypewriter(pageIndex) {
        typewriterBuffer = '';
        typewriterDisplayed = '';
        typewriterPageIndex = pageIndex;
        if (typewriterTimer) {
            clearInterval(typewriterTimer);
        }
        typewriterTimer = setInterval(typewriterTick, TYPEWRITER_SPEED);
    }

    // タイプライター停止
    function stopTypewriter() {
        if (typewriterTimer) {
            clearInterval(typewriterTimer);
            typewriterTimer = null;
        }
    }

    // タイプライターにテキストを追加（ストリームから呼ばれる）
    function appendToTypewriter(text) {
        typewriterBuffer = text;
    }

    // タイプライター1文字表示
    function typewriterTick() {
        if (typewriterDisplayed.length < typewriterBuffer.length) {
            typewriterDisplayed = typewriterBuffer.substring(0, typewriterDisplayed.length + 1);
            if (typewriterPageIndex >= 0) {
                updatePageText(typewriterPageIndex, typewriterDisplayed);
            }
        }
    }

    // タイプライター完了を待つ
    async function waitForTypewriter() {
        return new Promise(resolve => {
            const checkComplete = () => {
                if (typewriterDisplayed.length >= typewriterBuffer.length) {
                    stopTypewriter();
                    resolve();
                } else {
                    setTimeout(checkComplete, 50);
                }
            };
            checkComplete();
        });
    }

    // ページステータス更新（次へ/前へボタン表示判定）
    function updatePageStatus() {
        const statusEl = document.getElementById('page-status');
        const prevStatusEl = document.getElementById('page-status-prev');

        // 次へボタン
        if (statusEl) {
            if (isLoading) {
                // 読み込み中
                statusEl.innerHTML = '<span class="page-status-loading">読込中...</span>';
                statusEl.style.display = 'block';
            } else if (currentPageIndex >= 0 && currentPageIndex < pages.length - 1) {
                // 未読ページがある場合
                statusEl.innerHTML = '<button class="page-status-next" onclick="nextPage()">次へ</button>';
                statusEl.style.display = 'block';
            } else {
                // 最新ページ表示中
                statusEl.style.display = 'none';
            }
        }

        // 前へボタン
        if (prevStatusEl) {
            if (currentPageIndex > 0 && !isLoading) {
                prevStatusEl.innerHTML = '<button class="page-status-prev-btn" onclick="prevPage()">前へ</button>';
                prevStatusEl.style.display = 'block';
            } else {
                prevStatusEl.style.display = 'none';
            }
        }
    }

    // 移動モード切り替え
    function toggleMoveMode() {
        moveWithCompanion = !moveWithCompanion;
        updateMoveModeButton();
    }

    function updateMoveModeButton() {
        const btn = document.getElementById('move-mode-toggle');
        if (btn) {
            btn.textContent = moveWithCompanion ? '一緒に' : '一人で';
            btn.classList.toggle('active', moveWithCompanion);
        }
    }

    // サイドバー開閉
    const SIDEBAR_COLLAPSED_KEY = 'transition_sidebar_collapsed';
    let sidebarCollapsed = false;

    function toggleSidebar() {
        sidebarCollapsed = !sidebarCollapsed;
        const container = document.getElementById('appContainer');
        const toggleBtn = document.getElementById('sidebarToggle');
        if (sidebarCollapsed) {
            container.classList.add('sidebar-collapsed');
            toggleBtn.textContent = '▶';
        } else {
            container.classList.remove('sidebar-collapsed');
            toggleBtn.textContent = '☰';
        }
        localStorage.setItem(SIDEBAR_COLLAPSED_KEY, sidebarCollapsed ? 'yes' : 'no');
    }

    function initSidebarState() {
        const saved = localStorage.getItem(SIDEBAR_COLLAPSED_KEY);
        if (saved === 'yes') {
            sidebarCollapsed = true;
            const container = document.getElementById('appContainer');
            const toggleBtn = document.getElementById('sidebarToggle');
            container.classList.add('sidebar-collapsed');
            toggleBtn.textContent = '▶';
        }
    }

    // 設定モーダル開閉
    function openSettings() {
        document.getElementById('settingsModal').classList.add('active');
    }

    function closeSettings() {
        document.getElementById('settingsModal').classList.remove('active');
    }

    // モーダル外クリックで閉じる
    document.addEventListener('click', (e) => {
        const modal = document.getElementById('settingsModal');
        if (e.target === modal) {
            closeSettings();
        }
    });

    // 画像生成On/Off切り替え
    function toggleImageGen() {
        imageGenEnabled = !imageGenEnabled;
        localStorage.setItem(IMAGE_GEN_ENABLED_KEY, imageGenEnabled ? 'on' : 'off');
        updateImageGenButton();
    }

    function updateImageGenButton() {
        const btn = document.getElementById('imageGenToggle');
        if (btn) {
            btn.textContent = imageGenEnabled ? 'ON' : 'OFF';
            btn.style.background = imageGenEnabled ? '#4a9eff' : '#555';
        }
    }

    // APIキー保存
    function saveChatApiKey() {
        const key = document.getElementById('chatApiKey').value.trim();
        if (key) {
            localStorage.setItem(CHAT_API_KEY, key);
        }
    }

    function saveRunwareApiKey() {
        const key = document.getElementById('runwareApiKey').value.trim();
        if (key) {
            localStorage.setItem(RUNWARE_API_KEY, key);
        }
    }

    // LLMログOn/Off切り替え
    function toggleLLMLog() {
        llmLogEnabled = !llmLogEnabled;
        localStorage.setItem(LLM_LOG_ENABLED_KEY, llmLogEnabled ? 'on' : 'off');
        updateLLMLogButton();
    }

    function updateLLMLogButton() {
        const btn = document.getElementById('llmLogToggle');
        if (btn) {
            btn.textContent = llmLogEnabled ? 'ON' : 'OFF';
            btn.style.background = llmLogEnabled ? '#4a9eff' : '#555';
        }
    }

    // モデル選択プルダウン更新
    function updateModelSelect() {
        const select = document.getElementById('modelSelect');
        if (!select) return;

        select.innerHTML = '<option value="">-- モデル選択 --</option>';
        Object.keys(models).forEach(modelId => {
            const model = models[modelId];
            const selected = modelId === selectedModelId ? ' selected' : '';
            select.innerHTML += `<option value="${modelId}"${selected}>${model.name || modelId}</option>`;
        });
    }

    // モデル選択変更時（画像生成用）
    function onModelSelect() {
        const select = document.getElementById('modelSelect');
        selectedModelId = select.value;
        localStorage.setItem(SELECTED_MODEL_KEY, selectedModelId);
        console.log('[画像モデル選択]', selectedModelId);
    }

    // LLMモデル選択変更時
    function onLLMModelSelect() {
        const select = document.getElementById('llmModelSelect');
        selectedLLMModelId = select.value;
        localStorage.setItem(SELECTED_LLM_MODEL_KEY, selectedLLMModelId);
        console.log('[LLMモデル選択]', selectedLLMModelId);
    }

    // LLMモデル選択の初期化
    function initLLMModelSelect() {
        const savedLLMModelId = localStorage.getItem(SELECTED_LLM_MODEL_KEY);
        if (savedLLMModelId && LLM_MODELS[savedLLMModelId]) {
            selectedLLMModelId = savedLLMModelId;
        }
        const select = document.getElementById('llmModelSelect');
        if (select) {
            select.value = selectedLLMModelId;
        }
    }

    // 登場人数変更時
    function onCharacterCountChange() {
        const input = document.getElementById('characterCountInput');
        let value = parseInt(input.value);
        if (isNaN(value) || value < 1) value = 1;
        if (value > 10) value = 10;
        input.value = value;
        characterCount = value;
        localStorage.setItem(CHARACTER_COUNT_KEY, characterCount);
        updateCharacterStatusArray();
        renderCharacterSections();
        updateCharacterStatusDisplay();
        console.log('[登場人数]', characterCount);
    }

    // 登場人数の初期化
    function initCharacterCount() {
        const savedCount = localStorage.getItem(CHARACTER_COUNT_KEY);
        if (savedCount) {
            characterCount = parseInt(savedCount);
        }
        const input = document.getElementById('characterCountInput');
        if (input) {
            input.value = characterCount;
        }
        updateCharacterStatusArray();
        renderCharacterSections();
    }

    // characterStatus配列を登場人数に合わせて調整
    function updateCharacterStatusArray() {
        while (characterStatus.length < characterCount) {
            characterStatus.push({
                characterIndex: -1,
                placeIndex: -1,
                actionIndex: -1,
                relationshipId: 'rel_001',
                memo: ''
            });
        }
    }

    // キャラクターセクションを動的生成
    function renderCharacterSections() {
        const container = document.getElementById('characters-container');
        if (!container) return;

        container.innerHTML = '';
        for (let i = 0; i < characterCount; i++) {
            const section = document.createElement('div');
            section.className = 'current-state';
            section.id = `char${i + 1}-section`;
            section.innerHTML = `
                <div style="display:flex; gap:10px; align-items:flex-start;">
                    <img id="char${i + 1}-image" src="" alt="" style="width:90px; height:90px; object-fit:cover; border-radius:4px; background:#333; display:none;">
                    <div style="flex:1; font-size:0.85rem; line-height:1.4;">
                        <div><span id="char${i + 1}-name" style="color:#fff;">未選択</span><span id="char${i + 1}-relationship" style="color:#888;">：未設定</span></div>
                        <button class="place-btn" id="char${i + 1}-place" onclick="moveToCharacterLocation(${i})" style="color:#fff; background:#333; border:1px solid #444; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:0.8rem; margin:4px 0;">未選択</button>
                        <div class="memo-line" id="char${i + 1}-memo"></div>
                    </div>
                </div>
            `;
            container.appendChild(section);
        }
    }

    // ターゲットタイプ切り替え（移動/行為）
    function toggleTargetType() {
        currentTargetType = currentTargetType === 'move' ? 'action' : 'move';
        document.getElementById('target-toggle').textContent = currentTargetType === 'move' ? '移動' : '行為';
        updateTargetSelect();
    }

    function setTargetType(type) {
        currentTargetType = type;
        document.getElementById('target-toggle').textContent = type === 'move' ? '移動' : '行為';
        updateTargetSelect();
    }

    // ターゲット選択プルダウン更新
    function updateTargetSelect() {
        const select = document.getElementById('target-select');
        select.innerHTML = '';

        if (currentTargetType === 'move') {
            places.forEach((place, i) => {
                if (place.command_list === 'use') {
                    const selected = i === userState.placeIndex ? ' selected' : '';
                    select.innerHTML += `<option value="${i}"${selected}>${place.name}</option>`;
                }
            });
        } else {
            actions.forEach((action, i) => {
                if (action.command_list === 'use') {
                    const selected = i === currentState.actionIndex ? ' selected' : '';
                    select.innerHTML += `<option value="${i}"${selected}>${action.name}</option>`;
                }
            });
        }
    }

    // ターゲット選択時
    async function onTargetSelect() {
        const select = document.getElementById('target-select');
        const index = parseInt(select.value);
        if (isNaN(index) || index < 0) return;

        if (currentTargetType === 'move') {
            // ユーザーの場所変更
            const previousPlace = userState.placeIndex >= 0 ? places[userState.placeIndex] : null;

            // 「一緒に」モードの場合、現在地のキャラクターも一緒に移動
            let companion = null;
            if (moveWithCompanion) {
                console.log('[移動モード] 一緒にモード ON, ユーザー現在地:', userState.placeIndex);
                const charAtLocation = getCharacterAtUserLocation();
                console.log('[移動モード] 現在地のキャラ:', charAtLocation);
                if (charAtLocation) {
                    companion = charAtLocation;
                    // characterStatus配列を直接更新
                    const statusIndex = characterStatus.indexOf(charAtLocation.status);
                    console.log('[移動モード] statusIndex:', statusIndex, '移動先:', index);
                    if (statusIndex >= 0) {
                        characterStatus[statusIndex].placeIndex = index;
                        // 移動先のデフォルトアクションに変更
                        const newPlace = places[index];
                        if (newPlace && newPlace.default_action) {
                            const newActionIndex = actions.findIndex(a => a.action_id === newPlace.default_action);
                            if (newActionIndex >= 0) {
                                characterStatus[statusIndex].actionIndex = newActionIndex;
                                console.log('[一緒に移動] アクション変更:', actions[newActionIndex]?.name);
                            }
                        }
                    }
                    updateCharacterStatusDisplay();
                    console.log('[一緒に移動]', charAtLocation.character.name, '→', places[index]?.name);
                }
            }

            userState.placeIndex = index;
            updateUserStatusDisplay();
            const newPlace = places[index];

            // ページ生成
            await generatePages('move', '', previousPlace, newPlace, companion);
        } else {
            // アクション選択（実行はしない）
            currentState.actionIndex = index;
            console.log('[行為選択]', actions[index]?.name);
        }
    }

    // アクション実行（ボタンまたはEnterキーで呼び出し）
    async function runSelectedAction() {
        if (currentTargetType !== 'action' || currentState.actionIndex < 0) return;
        await executeAction(currentState.actionIndex);
    }

    // コマンドタイプ切り替え（発言→行為→脚本→発言...）
    const commandTypes = ['speech', 'action', 'scenario'];
    const commandLabels = { speech: '発言', action: '行為', scenario: '脚本' };
    const commandPlaceholders = {
        speech: '発言内容を入力...',
        action: '行為内容を入力...',
        scenario: '脚本指示を入力...'
    };

    function toggleCommandType() {
        const currentIndex = commandTypes.indexOf(currentCommandType);
        const nextIndex = (currentIndex + 1) % commandTypes.length;
        currentCommandType = commandTypes[nextIndex];
        document.getElementById('cmd-toggle').textContent = commandLabels[currentCommandType];
        document.getElementById('command-input').placeholder = commandPlaceholders[currentCommandType];
    }

    function setCommandType(type) {
        currentCommandType = type;
        document.getElementById('cmd-toggle').textContent = commandLabels[type];
        document.getElementById('command-input').placeholder = commandPlaceholders[type];
    }

    // コマンド実行
    async function executeCommand() {
        const input = document.getElementById('command-input');
        const text = input.value.trim();
        const hasAction = currentTargetType === 'action' && currentState.actionIndex >= 0;

        // テキストも行為もない場合は何もしない
        if (!text && !hasAction) return;

        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) {
            alert('OpenRouter API Key を入力してください');
            return;
        }
        localStorage.setItem(CHAT_API_KEY, chatApiKey);

        if (userState.placeIndex < 0) {
            alert('初期設定を実行してください');
            return;
        }

        // 行為のみ（テキストなし）
        if (!text && hasAction) {
            await runSelectedAction();
            return;
        }

        // 行為＋テキスト（発言しながら行為）
        if (text && hasAction) {
            const action = actions[currentState.actionIndex];
            addCommandMessage('行為＋発言', `${action.name} / 「${text}」`);
            input.value = '';
            await generatePages('action_with_speech', text, null, null);
            return;
        }

        // テキストのみ
        const typeLabels = {
            speech: '発言',
            action: '行為',
            scenario: '脚本'
        };

        addCommandMessage(typeLabels[currentCommandType], text);
        input.value = '';

        // ページ生成
        await generatePages(currentCommandType, text, null, null);
    }

    // Grok API呼び出し
    async function sendToGrok(commandType, userInput) {
        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        const char = characters[currentState.characterIndex];
        const place = currentState.placeIndex >= 0 ? places[currentState.placeIndex] : null;
        const action = currentState.actionIndex >= 0 ? actions[currentState.actionIndex] : null;

        // システムプロンプト構築（テンプレートから取得）
        const charTemplate = getPromptTemplate(promptTemplates, 'llm_002', { name: char.name });
        // テンプレートが " + " で分割されている場合、前半と後半に分ける
        const templateParts = charTemplate ? charTemplate.split(' + ') : [];
        let systemPrompt = templateParts[0] || `あなたは「${char.name}」というキャラクターです。`;
        if (char.series) systemPrompt += `作品「${char.series}」に登場します。`;
        if (char.profile) systemPrompt += `\n\nプロフィール: ${char.profile}`;
        if (place) systemPrompt += `\n\n現在の場所: ${place.name}`;
        if (action) systemPrompt += `\n\n現在のアクション: ${action.name}`;
        systemPrompt += `\n\n${templateParts[1] || 'キャラクターとして自然に応答してください。'}`;

        // ユーザーメッセージ構築
        let userMessage = '';
        if (commandType === 'speech') {
            userMessage = `[プレイヤーの発言]: ${userInput}`;
        } else if (commandType === 'action') {
            userMessage = `[プレイヤーの行為]: ${userInput}\n\nこの行為に対するキャラクターの反応を描写してください。`;
        } else if (commandType === 'scenario') {
            userMessage = `[脚本指示]: ${userInput}\n\nこの状況でキャラクターがどう反応するか描写してください。`;
        }

        chatHistory.push({ role: 'user', content: userMessage });

        const messages = [
            { role: 'system', content: systemPrompt },
            ...chatHistory
        ];

        console.log('[Grok] モデル:', selectedLLMModelId);
        console.log('[Grok] システムプロンプト:', systemPrompt);
        console.log('[Grok] メッセージ履歴:', JSON.stringify(chatHistory, null, 2));
        console.log('[Grok] 送信メッセージ:', JSON.stringify(messages, null, 2));

        // ストリーミング用のメッセージ要素を作成
        const messagesDiv = document.getElementById('chat-messages');
        const msgDiv = document.createElement('div');
        msgDiv.className = 'message transition';
        msgDiv.innerHTML = `<div class="action-name">${char.name}</div><div class="action-prompt" id="streaming-content">...</div>`;
        messagesDiv.appendChild(msgDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        const streamingContent = document.getElementById('streaming-content');
        let fullReply = '';

        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${chatApiKey}`
                },
                body: JSON.stringify({
                    model: selectedLLMModelId,
                    messages: messages,
                    stream: true
                })
            });

            if (!response.ok) {
                const error = await response.json();
                streamingContent.textContent = `エラー: ${error.error?.message || response.statusText}`;
                streamingContent.removeAttribute('id');
                return;
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(data);
                            const delta = parsed.choices?.[0]?.delta?.content;
                            if (delta) {
                                fullReply += delta;
                                streamingContent.innerHTML = fullReply.replace(/\n/g, '<br>');
                                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                            }
                        } catch (e) {
                            // JSONパースエラーは無視
                        }
                    }
                }
            }

            // ストリーミング完了
            streamingContent.removeAttribute('id');
            if (fullReply) {
                chatHistory.push({ role: 'assistant', content: fullReply });
                console.log('[Grok] 応答完了:', fullReply);
            }
        } catch (error) {
            console.error(error);
            streamingContent.textContent = `通信エラー: ${error.message}`;
            streamingContent.removeAttribute('id');
        }
    }

    // コマンドメッセージ追加（コンソールのみ）
    function addCommandMessage(type, text) {
        console.log(`[${type}]`, text);
    }

    // アシスタントメッセージ追加
    function addAssistantMessage(name, text) {
        addPage({
            type: 'dialogue',
            image: null,
            text: text,
            label: name
        });
    }

    // 初期化
    document.addEventListener('DOMContentLoaded', () => {
        // サイドバー状態復元
        initSidebarState();

        const settings = loadSettings(STORAGE_KEYS.GAS_URL, STORAGE_KEYS.API_KEY);
        if (settings.gasUrl) document.getElementById('gasUrl').value = settings.gasUrl;

        // API Key 復元
        const savedApiKey = localStorage.getItem(CHAT_API_KEY);
        if (savedApiKey) document.getElementById('chatApiKey').value = savedApiKey;

        const savedRunwareKey = localStorage.getItem(RUNWARE_API_KEY);
        if (savedRunwareKey) document.getElementById('runwareApiKey').value = savedRunwareKey;

        // 画像生成On/Off状態を復元
        const savedImageGenEnabled = localStorage.getItem(IMAGE_GEN_ENABLED_KEY);
        imageGenEnabled = savedImageGenEnabled !== 'off';
        updateImageGenButton();

        // LLMログOn/Off状態を復元
        const savedLLMLogEnabled = localStorage.getItem(LLM_LOG_ENABLED_KEY);
        llmLogEnabled = savedLLMLogEnabled === 'on';
        updateLLMLogButton();

        // モデル選択の復元
        const savedModelId = localStorage.getItem(SELECTED_MODEL_KEY);
        if (savedModelId) selectedModelId = savedModelId;

        // LLMモデル選択の初期化
        initLLMModelSelect();

        // 登場人数の初期化
        initCharacterCount();

        // ターゲットタイプ初期化
        setTargetType('move');

        loadCachedData();

        // 初期設定を自動実行
        startInitialSetup();

        // キーボードナビゲーション
        document.addEventListener('keydown', (e) => {
            // 入力フィールドにフォーカスがある場合は無視
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                nextPage();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                prevPage();
            }
        });
    });

    function saveCachedData() {
        localStorage.setItem(CACHE_KEY, JSON.stringify({ models, characters, places, actions, relationships, promptTemplates }));
    }

    function loadCachedData() {
        try {
            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
                const data = JSON.parse(cached);
                models = data.models || {};
                characters = data.characters || [];
                places = data.places || [];
                actions = data.actions || [];
                relationships = data.relationships || [];
                promptTemplates = data.promptTemplates || {};
                updateAllSelects();
                updateTargetSelect();
                updateModelSelect();
                if (actions.length > 0) {
                    addSystemMessage(`キャッシュから復元: ${characters.length}キャラ, ${places.length}場所, ${actions.length}アクション`);
                }
            }
        } catch (e) {
            console.error('Cache load error:', e);
        }
    }

    async function loadAllFromGas() {
        const baseUrl = document.getElementById('gasUrl').value.trim();
        if (!baseUrl) {
            alert('GAS URLを入力してください');
            return;
        }

        localStorage.setItem(STORAGE_KEYS.GAS_URL, baseUrl);
        showStatus('読み込み中...', 'loading');

        try {
            const [modelData, characterData, placeData, actionData, relationshipData, promptData] = await Promise.all([
                fetchGasData(baseUrl, 'model'),
                fetchGasData(baseUrl, 'character'),
                fetchGasData(baseUrl, 'place'),
                fetchGasData(baseUrl, 'action'),
                fetchGasData(baseUrl, 'relationship'),
                fetchGasData(baseUrl, 'llm_prompt_template')
            ]);

            models = parseModels(modelData);
            characters = parseCharacters(characterData);
            places = parsePlaces(placeData);
            actions = parseActionsWithCompositions(actionData);
            relationships = parseRelationships(relationshipData);
            promptTemplates = parsePromptTemplates(promptData);

            saveCachedData();
            updateAllSelects();
            updateTargetSelect();
            updateModelSelect();

            showStatus(`読込完了: ${characters.length}キャラ, ${places.length}場所, ${actions.length}アクション`);
            addSystemMessage(`データ読み込み完了: ${characters.length}キャラ, ${places.length}場所, ${actions.length}アクション`);
        } catch (error) {
            console.error(error);
            showStatus('エラー: ' + error.message, 'error');
        }
    }

    function updateAllSelects() {
        // プルダウン削除済み - ターゲット選択のみ更新
        updateTargetSelect();
    }

    async function executeAction(actionIndex) {
        const action = actions[actionIndex];
        if (!action) return;

        const prevActionIndex = currentState.actionIndex;
        const prevAction = prevActionIndex >= 0 ? actions[prevActionIndex] : null;

        // 状態更新
        currentState.actionIndex = actionIndex;

        // 同じ場所にいるキャラクターのアクションも更新
        const charAtLocation = getCharacterAtUserLocation();
        if (charAtLocation) {
            const statusIndex = characterStatus.findIndex(s => s === charAtLocation.status);
            if (statusIndex >= 0) {
                characterStatus[statusIndex].actionIndex = actionIndex;
                console.log('[アクション実行]', charAtLocation.character.name, 'のアクションを更新:', action.name);
                updateCharacterStatusDisplay();
            }
        }

        // 履歴に追加
        actionHistory.push({
            timestamp: new Date().toISOString(),
            fromAction: prevAction?.action_id || null,
            toAction: action.action_id,
            character: charAtLocation?.character?.name || null,
            place: userState.placeIndex >= 0 ? places[userState.placeIndex]?.name : null
        });

        // ページ生成（アクション実行）
        await generatePages('action_select', action.name, null, null);
    }

    // ========== ページ管理関数 ==========

    // ページを追加（DOM要素を事前作成）
    function addPage(pageData) {
        const pageIndex = pages.length;
        // fullTextを保存し、typewriterCompletedフラグを追加
        pageData.fullText = pageData.text;
        pageData.typewriterCompleted = false;
        pages.push(pageData);

        // DOM要素を作成
        const pageView = document.getElementById('page-view');
        const pageDiv = document.createElement('div');
        pageDiv.className = 'page-content';
        pageDiv.dataset.pageIndex = pageIndex;
        pageDiv.style.display = 'none';

        let imageHtml = '';
        if (pageData.image) {
            imageHtml = `<img src="${pageData.image}" alt="${pageData.label}">`;
        } else if (pageData.type !== 'system' && pageData.type !== 'dialogue') {
            imageHtml = '<div class="placeholder">画像なし</div>';
        }

        let labelClass = '';
        if (pageData.type === 'character' || pageData.type === 'dialogue') {
            labelClass = 'character';
        }

        const showImage = pageData.type !== 'system' && pageData.type !== 'dialogue';
        // 初期テキストを表示（ページ切り替え時にタイプライターで再表示）
        pageDiv.innerHTML = `
            ${showImage ? `<div class="page-image">${imageHtml}</div>` : ''}
            <div class="page-text ${pageData.type === 'dialogue' ? 'dialogue-text' : ''}">
                <span class="page-label ${labelClass}">${pageData.label}</span>
                <div>${pageData.text.replace(/\n/g, '<br>')}</div>
            </div>
        `;

        pageView.appendChild(pageDiv);

        updatePageIndicator();

        // 最初のページの場合は表示
        if (pages.length === 1) {
            currentPageIndex = 0;
            showPage(0);
        }
    }

    // 指定インデックスのページを表示（display切り替えのみ）
    function showPage(index) {
        if (index < 0 || index >= pages.length) return;
        currentPageIndex = index;

        // 全ページを非表示にして、指定ページのみ表示
        const pageView = document.getElementById('page-view');
        const pageContents = pageView.querySelectorAll('.page-content');
        pageContents.forEach((el, i) => {
            el.style.display = (i === index) ? 'flex' : 'none';
        });

        updatePageIndicator();
        updatePageStatus();

        // タイプライター未完了のページならタイプライター開始
        const page = pages[index];
        if (page && !page.typewriterCompleted && page.fullText) {
            // テキストをクリアしてタイプライター開始
            const pageView = document.getElementById('page-view');
            const pageDiv = pageView.querySelector(`.page-content[data-page-index="${index}"]`);
            if (pageDiv) {
                const textDiv = pageDiv.querySelector('.page-text > div');
                if (textDiv) textDiv.innerHTML = '';
            }
            startPageTypewriter(index);
        }
    }

    // ページ切り替え時のタイプライター開始
    function startPageTypewriter(pageIndex) {
        const page = pages[pageIndex];
        if (!page || !page.fullText) return;

        // 既存のタイプライターを停止
        stopTypewriter();

        // タイプライター設定
        typewriterBuffer = page.fullText;
        typewriterDisplayed = '';
        typewriterPageIndex = pageIndex;

        // タイマー開始
        typewriterTimer = setInterval(() => {
            if (typewriterDisplayed.length < typewriterBuffer.length) {
                typewriterDisplayed = typewriterBuffer.substring(0, typewriterDisplayed.length + 1);
                updatePageText(typewriterPageIndex, typewriterDisplayed);
            } else {
                // 完了
                stopTypewriter();
                pages[typewriterPageIndex].typewriterCompleted = true;
            }
        }, TYPEWRITER_SPEED);
    }

    // 次のページへ
    function nextPage() {
        if (currentPageIndex < pages.length - 1) {
            showPage(currentPageIndex + 1);
        }
    }

    // 前のページへ
    function prevPage() {
        if (currentPageIndex > 0) {
            showPage(currentPageIndex - 1);
        }
    }

    // 最新ページへ
    function goToLatestPage() {
        if (pages.length > 0) {
            showPage(pages.length - 1);
        }
    }

    // ページインジケーター更新
    function updatePageIndicator() {
        const indicator = document.getElementById('page-indicator');
        if (indicator) {
            if (pages.length === 0) {
                indicator.textContent = '-- / --';
            } else {
                indicator.textContent = `${currentPageIndex + 1} / ${pages.length}`;
            }
        }
        // ナビボタンの有効/無効
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        if (prevBtn) prevBtn.disabled = currentPageIndex <= 0;
        if (nextBtn) nextBtn.disabled = currentPageIndex >= pages.length - 1;
    }

    // ========== メッセージ追加関数（システムログはコンソールのみ） ==========

    function addSystemMessage(text) {
        console.log('[System]', text);
    }

    function addStateChangeMessage(text) {
        console.log('[StateChange]', text);
    }

    function addActionMessage(action, label) {
        console.log('[Action]', label, action.name);
    }

    function addTransitionMessage(fromAction, toAction) {
        console.log('[Transition]', fromAction.name, '→', toAction.name);
    }

    function clearChat() {
        pages = [];
        currentPageIndex = -1;
        actionHistory = [];
        chatHistory = [];
        // DOM要素を全削除
        const pageView = document.getElementById('page-view');
        pageView.innerHTML = '';
        updatePageIndicator();
        console.log('[System] チャットをクリアしました');
    }

    // 履歴をコンソールに出力（デバッグ用）
    function dumpHistory() {
        console.log('Action History:', actionHistory);
        return actionHistory;
    }

    // キャラクターステータス表示更新
    function updateCharacterStatusDisplay() {
        for (let i = 0; i < characterCount; i++) {
            const status = characterStatus[i];
            if (!status) continue;
            const num = i + 1;
            const char = status.characterIndex >= 0 ? characters[status.characterIndex] : null;
            const place = status.placeIndex >= 0 ? places[status.placeIndex] : null;
            const action = status.actionIndex >= 0 ? actions[status.actionIndex] : null;
            const relationship = relationships.find(r => r.relationship_id === status.relationshipId);

            const imageEl = document.getElementById(`char${num}-image`);
            const nameEl = document.getElementById(`char${num}-name`);
            const placeEl = document.getElementById(`char${num}-place`);
            const relationshipEl = document.getElementById(`char${num}-relationship`);
            const memoEl = document.getElementById(`char${num}-memo`);

            if (imageEl) {
                if (char && char.image) {
                    imageEl.src = char.image;
                    imageEl.style.display = 'block';
                } else {
                    imageEl.src = '';
                    imageEl.style.display = 'none';
                }
            }
            if (nameEl) nameEl.textContent = char ? char.name : '未選択';
            if (placeEl) placeEl.textContent = place ? place.name : '未選択';
            if (relationshipEl) relationshipEl.textContent = '：' + (relationship ? relationship.name : '未設定');
            if (memoEl) memoEl.textContent = status.memo ? `メモ：${status.memo}` : '';
        }
    }

    // 初期設定開始
    function startInitialSetup() {
        // cast='on' のキャラクターを取得
        const castCharacters = characters
            .map((char, index) => ({ char, index }))
            .filter(item => item.char.cast === 'on');

        if (castCharacters.length < characterCount) {
            addSystemMessage(`cast=onのキャラクターが${characterCount}人以上必要です。GASから読み込んでください。`);
            return;
        }

        // publicな場所を取得
        const publicPlaces = places
            .map((place, index) => ({ place, index }))
            .filter(item => item.place.public_flag === 'public');

        if (publicPlaces.length < characterCount) {
            addSystemMessage(`publicな場所が${characterCount}つ以上必要です。`);
            return;
        }

        // キャラクターをランダム選択（cast=onから、重複なし）
        const charIndices = [];
        const shuffledCast = [...castCharacters].sort(() => Math.random() - 0.5);
        for (let i = 0; i < characterCount; i++) {
            charIndices.push(shuffledCast[i].index);
        }

        // 場所をランダム選択（重複なし）
        const placeIndices = [];
        while (placeIndices.length < characterCount) {
            const randItem = publicPlaces[Math.floor(Math.random() * publicPlaces.length)];
            if (!placeIndices.includes(randItem.index)) {
                placeIndices.push(randItem.index);
            }
        }

        // ステータスを設定（デフォルトアクションも設定）
        for (let i = 0; i < characterCount; i++) {
            const place = places[placeIndices[i]];
            // 場所のデフォルトアクションからアクションインデックスを取得
            let actionIndex = -1;
            if (place && place.default_action) {
                actionIndex = actions.findIndex(a => a.action_id === place.default_action);
            }

            characterStatus[i] = {
                characterIndex: charIndices[i],
                placeIndex: placeIndices[i],
                actionIndex: actionIndex,
                relationshipId: 'rel_001',  // 初期値
                memo: ''  // メモ初期値
            };
        }

        // 後方互換: currentStateも更新
        currentState.characterIndex = charIndices[0];
        currentState.placeIndex = placeIndices[0];
        currentState.actionIndex = -1;

        // ユーザーの初期位置を「101号室 玄関」に設定
        const userPlaceIndex = places.findIndex(p => p.name === '101号室 玄関');
        userState.placeIndex = userPlaceIndex >= 0 ? userPlaceIndex : -1;

        updateCharacterStatusDisplay();
        updateUserStatusDisplay();
        updateTargetSelect();

        // 設定結果をメッセージで表示
        const userPlace = userState.placeIndex >= 0 ? places[userState.placeIndex] : null;
        addSystemMessage(`初期設定完了:`);
        for (let i = 0; i < characterCount; i++) {
            const char = characters[charIndices[i]];
            const place = places[placeIndices[i]];
            const action = characterStatus[i].actionIndex >= 0 ? actions[characterStatus[i].actionIndex] : null;
            addSystemMessage(`  ${char.name} → ${place.name} [${action?.name || 'なし'}]`);
        }
        addSystemMessage(`  ユーザー → ${userPlace ? userPlace.name : '未設定'}`);
    }

    // ユーザーステータス表示更新
    function updateUserStatusDisplay() {
        const place = userState.placeIndex >= 0 ? places[userState.placeIndex] : null;
        document.getElementById('user-place').textContent = place ? place.name : '未選択';
    }

    // キャラクターの現在地へ単独移動
    async function moveToCharacterLocation(charStatusIndex) {
        const status = characterStatus[charStatusIndex];
        if (!status || status.placeIndex < 0) {
            console.log('[移動] キャラクターの場所が未設定');
            return;
        }

        const targetPlaceIndex = status.placeIndex;

        // 既に同じ場所にいる場合は何もしない
        if (userState.placeIndex === targetPlaceIndex) {
            console.log('[移動] 既に同じ場所にいます');
            return;
        }

        const previousPlace = userState.placeIndex >= 0 ? places[userState.placeIndex] : null;
        const newPlace = places[targetPlaceIndex];

        // ユーザーの場所を更新
        userState.placeIndex = targetPlaceIndex;
        updateUserStatusDisplay();
        updateTargetSelect();

        console.log('[単独移動]', previousPlace?.name, '→', newPlace?.name);

        // ページ生成（単独移動、companion=null）
        await generatePages('move', '', previousPlace, newPlace, null);
    }

    // ユーザーと同じ場所にいるキャラクターを取得
    function getCharacterAtUserLocation() {
        if (userState.placeIndex < 0) return null;
        for (const status of characterStatus) {
            if (status.placeIndex === userState.placeIndex && status.characterIndex >= 0) {
                return {
                    character: characters[status.characterIndex],
                    status: status
                };
            }
        }
        return null;
    }

    // ページ1を追加（説明文 + 場所画像）- ページインデックスを返す
    function addPage1(placeImage, text) {
        const pageIndex = pages.length;
        addPage({
            type: 'narrative',
            image: placeImage,
            text: text,
            label: '状況'
        });
        return pageIndex;
    }

    // 指定ページのテキストを更新
    function updatePageText(pageIndex, newText) {
        if (pageIndex < 0 || pageIndex >= pages.length) return;

        // データ更新
        pages[pageIndex].text = newText;

        // DOM更新
        const pageView = document.getElementById('page-view');
        const pageDiv = pageView.querySelector(`.page-content[data-page-index="${pageIndex}"]`);
        if (pageDiv) {
            const textDiv = pageDiv.querySelector('.page-text > div');
            if (textDiv) {
                textDiv.innerHTML = newText.replace(/\n/g, '<br>');
            }
        }
    }

    // ページ2を追加（キャラクターセリフ + アクション画像）- ページインデックスを返す
    function addPage2(characterName, image, text) {
        const pageIndex = pages.length;
        addPage({
            type: 'character',
            image: image,
            text: text,
            label: characterName
        });
        return pageIndex;
    }

    // 会話モード：最後のページがdialogueまたはcharacterなら追記、そうでなければ新規ページ
    function addDialogue(characterName, text) {
        console.log('[addDialogue] 開始 - name:', characterName, '/ text:', text);
        const lastPage = pages[pages.length - 1];
        console.log('[addDialogue] lastPage type:', lastPage?.type, '/ pages.length:', pages.length);

        // 名前があれば「名前 テキスト」、なければテキストのみ
        const lineText = characterName ? `${characterName}${text}` : text;
        console.log('[addDialogue] lineText:', lineText);

        // 最後のページがdialogueまたはcharacterタイプなら追記
        if (lastPage && (lastPage.type === 'dialogue' || lastPage.type === 'character')) {
            console.log('[addDialogue] 追記モード開始');
            const pageIndex = pages.length - 1;
            // データ更新
            lastPage.text += `\n${lineText}`;
            lastPage.fullText = lastPage.text;
            console.log('[addDialogue] データ更新完了 - text:', lastPage.text);

            // 既存のタイプライターがあれば完了させる
            if (!lastPage.typewriterCompleted) {
                console.log('[addDialogue] タイプライター未完了 - 完了処理開始');
                // DOMに現在のテキスト（追記前）を反映
                const pageView = document.getElementById('page-view');
                const pageDiv = pageView.querySelector(`.page-content[data-page-index="${pageIndex}"]`);
                if (pageDiv) {
                    const textDiv = pageDiv.querySelector('.page-text > div');
                    if (textDiv) {
                        // 追記前のテキストを表示
                        const prevText = lastPage.text.split('\n').slice(0, -1).join('\n');
                        textDiv.innerHTML = prevText.replace(/\n/g, '<br>');
                    }
                }
                lastPage.typewriterCompleted = true;
                stopTypewriter();
            }

            // 最新ページへ移動（タイプライターは起動しない）
            showPage(pageIndex);

            // 追記テキストをタイプライター表示
            startAppendTypewriter(pageIndex, lineText);
        } else {
            // 新規ページ作成
            addPage({
                type: 'dialogue',
                image: null,
                text: lineText,
                label: '会話'
            });
            // ストリーミングではないのでタイプライターを起動させる
            goToLatestPage();
        }
    }

    // 追記テキストのタイプライター表示
    function startAppendTypewriter(pageIndex, appendText) {
        console.log('[startAppendTypewriter] 開始 - pageIndex:', pageIndex, '/ appendText:', appendText);
        // 既存のタイプライターを停止
        stopTypewriter();

        const pageView = document.getElementById('page-view');
        const pageDiv = pageView.querySelector(`.page-content[data-page-index="${pageIndex}"]`);
        if (!pageDiv) {
            console.error('[startAppendTypewriter] pageDiv not found');
            return;
        }

        const textDiv = pageDiv.querySelector('.page-text > div');
        if (!textDiv) {
            console.error('[startAppendTypewriter] textDiv not found');
            return;
        }

        // ページデータから追記前のテキストを取得してDOMに反映
        const page = pages[pageIndex];
        if (page) {
            // fullTextから追記分を除いた部分をDOMに設定
            const fullLines = page.fullText.split('\n');
            const appendLines = appendText.split('\n');
            // 末尾から追記分を除去
            const prevLines = fullLines.slice(0, fullLines.length - appendLines.length);
            const prevHtml = prevLines.join('\n').replace(/\n/g, '<br>');
            textDiv.innerHTML = prevHtml;
            console.log('[startAppendTypewriter] DOM更新完了 - prevHtml長:', prevHtml.length);
        }

        // 現在のDOM内容を保持
        const currentHtml = textDiv.innerHTML;
        let displayedCount = 0;
        const textToAppend = `\n${appendText}`;

        typewriterTimer = setInterval(() => {
            if (displayedCount < textToAppend.length) {
                displayedCount++;
                const partialText = textToAppend.substring(0, displayedCount);
                textDiv.innerHTML = currentHtml + partialText.replace(/\n/g, '<br>');
            } else {
                stopTypewriter();
            }
        }, TYPEWRITER_SPEED);
    }

    // ページ生成メイン処理
    // companion: 一緒に移動するキャラクター（移動時のみ使用）
    async function generatePages(actionType, userInput, previousPlace, newPlace, companion = null) {
        const chatApiKey = document.getElementById('chatApiKey').value.trim();
        if (!chatApiKey) {
            addSystemMessage('OpenRouter API Keyが必要です');
            return;
        }

        // 読み込み開始
        showLoading();

        const currentPlace = places[userState.placeIndex];
        // 移動時に一緒に移動した場合はcompanionを使用、それ以外は現在地のキャラクター
        const charAtLocation = companion || getCharacterAtUserLocation();

        // 発言かつキャラクターがいる場合は会話モード
        if (actionType === 'speech' && charAtLocation) {
            // ユーザーの発言を追加
            addDialogue('あなた', `「${userInput}」`);

            const { fullPrompt, simplePrompt } = buildCombinedPrompt(actionType, userInput, null, null, charAtLocation, currentPlace, true);
            console.log('[会話モード] 完全版プロンプト:', fullPrompt);
            console.log('[会話モード] シンプル版:', simplePrompt);

            const response = await callLLM(chatApiKey, fullPrompt, 'character', charAtLocation.character, null, simplePrompt);
            console.log('[会話モード] レスポンス:', response);

            // 関係性変化の判定を抽出
            const { dialogue: parsedDialogue, narrative, newRelationshipName, relationshipMemo } = parseConversationResponse(response, charAtLocation);
            console.log('[会話モード] セリフ:', parsedDialogue, '/ 地の文:', narrative, '/ 新関係性:', newRelationshipName, '/ メモ:', relationshipMemo);

            // 関係性変化の処理 - 名前から検索して更新
            const statusIndex = characterStatus.findIndex(s => s === charAtLocation.status);
            if (statusIndex >= 0) {
                // 関係性変化がある場合
                if (newRelationshipName) {
                    const currentRelationshipId = charAtLocation.status.relationshipId;
                    const currentRelationship = relationships.find(r => r.relationship_id === currentRelationshipId);
                    // 名前で関係性を検索
                    const newRelationship = relationships.find(r => r.name === newRelationshipName);
                    if (newRelationship && newRelationship.relationship_id !== currentRelationshipId) {
                        characterStatus[statusIndex].relationshipId = newRelationship.relationship_id;
                        console.log('[関係性変化]', charAtLocation.character.name, ':', currentRelationship?.name, '→', newRelationship.name);
                        addSystemMessage(`💫 ${charAtLocation.character.name}との関係性が「${currentRelationship?.name || '不明'}」から「${newRelationship.name}」に変化しました`);
                    }
                }
                // メモがあれば保存（関係性変化がなくても）
                if (relationshipMemo) {
                    characterStatus[statusIndex].memo = relationshipMemo;
                    console.log('[メモ更新]', charAtLocation.character.name, ':', relationshipMemo);
                }
                updateCharacterStatusDisplay();
            }

            console.log('[会話モード] addDialogue呼び出し前 - キャラ:', charAtLocation.character.name, '/ セリフ:', parsedDialogue);
            if (parsedDialogue) {
                addDialogue(charAtLocation.character.name, parsedDialogue);
                console.log('[会話モード] addDialogue完了');
            } else {
                console.warn('[会話モード] セリフが空です');
            }
            // 地の文があれば追加
            if (narrative) {
                addDialogue('', narrative);
                console.log('[会話モード] 地の文追加完了');
            }
            hideLoading();
            return;
        }

        // 発言だがキャラクターがいない場合
        if (actionType === 'speech' && !charAtLocation) {
            addSystemMessage('この場所には誰もいません');
            hideLoading();
            return;
        }

        // 移動時は即座にプレースホルダーページを作成
        let movePageIndex = -1;
        if (actionType === 'move' && newPlace) {
            const placeImage = newPlace.image || null;
            movePageIndex = addPage1(placeImage, `${newPlace.name}に移動...`);
            // ストリーミングで更新するのでshowPageからのタイプライター起動を防ぐ
            pages[movePageIndex].typewriterCompleted = true;
            goToLatestPage();
        }

        // 通常モード：LLMと画像生成を並列実行
        const { fullPrompt: combinedPrompt, simplePrompt: combinedSimplePrompt } = buildCombinedPrompt(actionType, userInput, previousPlace, newPlace, charAtLocation, currentPlace, false, companion);
        console.log('[Combined] 完全版プロンプト:', combinedPrompt);
        console.log('[Combined] シンプル版:', combinedSimplePrompt);

        // 画像生成を非同期に開始（setTimeoutでブロックを回避）
        let imagePromise = null;
        const runwareApiKey = document.getElementById('runwareApiKey').value.trim();
        if (charAtLocation && imageGenEnabled && runwareApiKey) {
            localStorage.setItem(RUNWARE_API_KEY, runwareApiKey);
            const charActionIndex = charAtLocation.status?.actionIndex ?? -1;
            imagePromise = new Promise(resolve => {
                setTimeout(async () => {
                    try {
                        const image = await generateCharacterImage(charAtLocation.character, currentPlace, charActionIndex);
                        resolve(image);
                    } catch (e) {
                        console.error('[画像生成エラー]', e);
                        resolve(null);
                    }
                }, 0);
            });
            console.log('[並列実行] LLM + 画像生成を開始');
        }

        // ストリーム用のページを先に作成
        const placeImage = currentPlace?.image || null;
        let streamPageIndex = -1;
        let useAddDialogueMode = false;  // アクション時は最後のページに追記
        let appendBaseHtml = '';  // アクション時の追記ベースHTML

        if (movePageIndex >= 0) {
            // 移動時：既存のプレースホルダーページを使用
            streamPageIndex = movePageIndex;
        } else {
            // アクション時：最後のページに追記モード
            useAddDialogueMode = true;
            // 現在の最後のページのHTMLを保存
            if (pages.length > 0) {
                const lastPageIndex = pages.length - 1;
                const pageView = document.getElementById('page-view');
                const pageDiv = pageView.querySelector(`.page-content[data-page-index="${lastPageIndex}"]`);
                if (pageDiv) {
                    const textDiv = pageDiv.querySelector('.page-text > div');
                    if (textDiv) {
                        appendBaseHtml = textDiv.innerHTML;
                    }
                }
            }
        }

        // ストリーミング用タイプライター開始（移動時のみ）
        if (streamPageIndex >= 0) {
            startTypewriter(streamPageIndex);
        }

        // デバッグ用フラグリセット
        window._streamDisplayStarted = false;
        window._chunkCallbackStarted = false;
        window._displayTextLogged = false;

        // ストリーム受信時のコールバック
        const onStreamChunk = (accumulatedText) => {
            if (!window._chunkCallbackStarted) {
                const elapsed = ((performance.now() - window._streamStartTime) / 1000).toFixed(3);
                console.log(`[onStreamChunk] コールバック初回呼び出し (${elapsed}秒)`);
                window._chunkCallbackStarted = true;
            }
            // 【地の文】タグがあればその内容を抽出、なければ全体を表示
            let displayText = accumulatedText;
            const narrativeMatch = accumulatedText.match(/【地の文】\s*([\s\S]*?)(?=【|$)/);
            if (narrativeMatch) {
                displayText = narrativeMatch[1].trim();
            } else {
                // まだ【地の文】が来ていない場合、【で始まる部分は除外
                const firstTag = accumulatedText.indexOf('【');
                if (firstTag > 0) {
                    displayText = accumulatedText.substring(0, firstTag).trim();
                }
            }

            // デバッグ：displayTextが空かどうか
            if (!window._displayTextLogged && displayText) {
                const elapsed = ((performance.now() - window._streamStartTime) / 1000).toFixed(3);
                console.log(`[onStreamChunk] displayText取得 (${elapsed}秒):`, displayText.substring(0, 50) + '...');
                window._displayTextLogged = true;
            }

            // タイプライターにテキストを追加
            if (streamPageIndex >= 0) {
                // 移動時：タイプライターで表示
                appendToTypewriter(displayText);
            } else if (useAddDialogueMode && pages.length > 0 && displayText) {
                // アクション時：最後のページに直接ストリーム表示
                const lastPageIndex = pages.length - 1;
                const pageView = document.getElementById('page-view');
                const pageDiv = pageView.querySelector(`.page-content[data-page-index="${lastPageIndex}"]`);
                if (pageDiv) {
                    const textDiv = pageDiv.querySelector('.page-text > div');
                    if (textDiv) {
                        if (!window._streamDisplayStarted) {
                            const elapsed = ((performance.now() - window._streamStartTime) / 1000).toFixed(3);
                            console.log(`[アクション] ページにテキスト追加開始 (${elapsed}秒)`);
                            window._streamDisplayStarted = true;
                        }
                        textDiv.innerHTML = appendBaseHtml + (appendBaseHtml ? '<br>' : '') + displayText.replace(/\n/g, '<br>');
                    }
                }
            }
        };

        // LLMの応答を待つ（ストリーム対応）
        const response = await callLLM(chatApiKey, combinedPrompt, 'combined', null, onStreamChunk, combinedSimplePrompt);

        console.log('[LLM] レスポンス:', response);
        const { narrative, dialogue, newRelationshipName, relationshipMemo } = parseCombinedResponse(response, charAtLocation);
        console.log('[LLM] パース結果 - 地の文:', narrative, '/ セリフ:', dialogue, '/ 新関係性:', newRelationshipName, '/ メモ:', relationshipMemo);

        // 最終的な地の文を表示
        if (streamPageIndex >= 0) {
            // 移動時：タイプライターで表示
            appendToTypewriter(narrative);
            await waitForTypewriter();
            // タイプライター完了後、fullTextを更新してフラグを立てる
            if (pages[streamPageIndex]) {
                pages[streamPageIndex].fullText = narrative;
                pages[streamPageIndex].typewriterCompleted = true;
            }
        } else if (useAddDialogueMode && narrative && pages.length > 0) {
            // アクション時：ストリームで既に表示済み、データのみ更新
            const lastPageIndex = pages.length - 1;
            const lastPage = pages[lastPageIndex];
            lastPage.text += (lastPage.text ? '\n' : '') + narrative;
            lastPage.fullText = lastPage.text;
        }

        // 関係性変化の処理 - 名前から検索して更新
        if (charAtLocation) {
            const statusIndex = characterStatus.findIndex(s => s === charAtLocation.status);
            if (statusIndex >= 0) {
                if (newRelationshipName) {
                    const currentRelationshipId = charAtLocation.status.relationshipId;
                    const currentRelationship = relationships.find(r => r.relationship_id === currentRelationshipId);
                    const newRelationship = relationships.find(r => r.name === newRelationshipName);
                    if (newRelationship && newRelationship.relationship_id !== currentRelationshipId) {
                        characterStatus[statusIndex].relationshipId = newRelationship.relationship_id;
                        console.log('[関係性変化]', charAtLocation.character.name, ':', currentRelationship?.name, '→', newRelationship.name);
                        addSystemMessage(`💫 ${charAtLocation.character.name}との関係性が「${currentRelationship?.name || '不明'}」から「${newRelationship.name}」に変化しました`);
                    }
                }
                if (relationshipMemo) {
                    characterStatus[statusIndex].memo = relationshipMemo;
                    console.log('[メモ更新]', charAtLocation.character.name, ':', relationshipMemo);
                }
                updateCharacterStatusDisplay();
            }
        }

        // 地の文表示完了
        console.log('[地の文表示完了]');

        // 画像生成がなければ読み込み完了
        if (!imagePromise) {
            hideLoading();
        }

        // ページ2: キャラクターがいてセリフがある場合のみ
        if (charAtLocation && dialogue) {
            const charImage = imagePromise ? await imagePromise : null;
            addPage2(charAtLocation.character.name, charImage, dialogue);
            updatePageStatus(); // 「次へ」ボタンを表示
        }

        // 読み込み完了
        hideLoading();
    }

    // 統合プロンプト構築
    // dialogueOnly: true の場合はセリフのみ要求（会話モード）
    // companion: 一緒に移動したキャラクター（移動時のみ）
    function buildCombinedPrompt(actionType, userInput, previousPlace, newPlace, charAtLocation, currentPlace, dialogueOnly = false, companion = null) {
        // 会話モード
        if (dialogueOnly && charAtLocation) {
            const charName = charAtLocation.character.name;
            const char = charAtLocation.character;
            let prompt = '';

            // キャラクター情報
            prompt += `【会話相手】${charName}`;
            if (char.series) prompt += `（${char.series}）`;
            if (char.profile) prompt += `\nプロフィール: ${char.profile}`;

            // 関係性情報
            const relationshipId = charAtLocation.status?.relationshipId;
            let relationship = null;
            if (relationshipId) {
                relationship = relationships.find(r => r.relationship_id === relationshipId);
                if (relationship) {
                    prompt += `\n現在の関係性: ${relationship.name}（${relationship.description || ''}）`;
                    // メモがあれば追加
                    if (charAtLocation.status?.memo) {
                        prompt += `\n関係性メモ: ${charAtLocation.status.memo}`;
                    }
                    // 進展条件があれば追加
                    if (relationship.next_relationship_req) {
                        prompt += `\n関係性進展条件: ${relationship.next_relationship_req}`;
                    }
                }
            }

            prompt += `\n\n主人公「${userInput}」\n`;

            // 出力フォーマット
            const dialogueInstruction = getPromptTemplate(promptTemplates, 'llm_003', { name: charName })
                || `【${charName}のセリフ】「」付きで1-2文で出力`;

            prompt += `\n${dialogueInstruction}`;
            prompt += `\n【地の文】必要な場合のみ、セリフの後の状況や動作を1行で記載（不要なら省略）`;

            // 関係性進展条件がある場合のみ判定を追加
            if (relationship && relationship.next_relationship_req) {
                prompt += `\n【関係性変化】この会話で関係性進展条件を満たした場合、もしくは総合的に関係性変化が起きたと判断される場合は新しい関係性名を記載、満たしていない場合は「維持」と記載`;
                prompt += `\n【関係性メモ】関係性が変化した場合は必ず記載。変化がなくてもメモ更新が必要な出来事があれば記載。キャラクター視点で50文字以内でどこで何が起きて、なぜその関係性になったのか、今後どうしていきたいか、キャラクターの感情を交えて記載。不要なら省略`;
            }

            // 完全版とシンプル版の両方を返す
            return {
                fullPrompt: prompt,
                simplePrompt: `会話：主人公「${userInput}」`
            };
        }

        let prompt = '';

        // 状況説明（日本語）
        let situationText = '';
        if (actionType === 'action_select' && currentState.actionIndex >= 0) {
            const action = actions[currentState.actionIndex];
            situationText = action?.name || '';
        } else if (actionType === 'action_with_speech' && currentState.actionIndex >= 0) {
            const action = actions[currentState.actionIndex];
            situationText = `${action?.name || ''} + 主人公の発言「${userInput}」`;
        } else if (actionType === 'action' || actionType === 'scenario') {
            situationText = userInput;
        } else if (actionType === 'move') {
            // 移動時専用テンプレート（llm_006）を使用
            const moveTemplate = getPromptTemplate(promptTemplates, 'llm_006', {
                from: previousPlace?.name || '',
                to: newPlace?.name || ''
            });
            console.log('[移動] from:', previousPlace?.name, 'to:', newPlace?.name, 'template:', moveTemplate);
            situationText = moveTemplate || `${previousPlace?.name || ''}から${newPlace?.name || ''}に移動`;

            // 一緒に移動した場合のみ、関係性をチェック
            if (companion) {
                const relId = companion.status?.relationshipId || '';
                const relNumMatch = relId.match(/^rel_(\d+)$/);
                if (relNumMatch) {
                    const relNum = parseInt(relNumMatch[1], 10);
                    if (relNum < 100) {
                        situationText += `（${companion.character.name}を無理やり連れて行った）`;
                        console.log('[移動] 関係性', relId, '< rel_100 → 無理やり連れて行った');
                    }
                }
            }
        } else if (actionType === 'speech') {
            situationText = `主人公の発言「${userInput}」`;
        }

        // 画像プロンプト（タグ）
        const imageParts = [];
        if (charAtLocation?.character?.tag) {
            imageParts.push(charAtLocation.character.tag);
        }
        if (currentPlace?.tag) {
            imageParts.push(currentPlace.tag);
        }
        // ユーザーのアクション（action_select/action_with_speech時）
        if ((actionType === 'action_select' || actionType === 'action_with_speech') && currentState.actionIndex >= 0) {
            const action = actions[currentState.actionIndex];
            if (action?.prompt) imageParts.push(action.prompt);
            const compositionTag = getCompositionTag(actions, currentState.actionIndex);
            console.log('[LLMプロンプト] ユーザーアクション:', action?.name, '構図:', compositionTag || '(なし)');
            if (compositionTag) imageParts.push(compositionTag);
        }
        // キャラクターのアクション（移動時など）
        const charActionIndex = charAtLocation?.status?.actionIndex ?? -1;
        if (charActionIndex >= 0 && actions[charActionIndex]) {
            const charAction = actions[charActionIndex];
            if (charAction?.prompt) imageParts.push(charAction.prompt);
            const charCompositionTag = getCompositionTag(actions, charActionIndex);
            console.log('[LLMプロンプト] キャラアクション:', charAction?.name, '構図:', charCompositionTag || '(なし)');
            if (charCompositionTag) imageParts.push(charCompositionTag);
        }
        if (currentPlace?.additionalTag) {
            imageParts.push(currentPlace.additionalTag);
        }
        if (charAtLocation?.character?.additionalTag) {
            imageParts.push(charAtLocation.character.additionalTag);
        }

        prompt += `状況：${situationText}\n`;
        prompt += `画像プロンプト：${imageParts.filter(p => p).join(', ')}\n`;

        if (charAtLocation) {
            const char = charAtLocation.character;
            prompt += `\n【その場にいる人物】${char.name}`;
            if (char.series) prompt += `（${char.series}）`;
            if (char.profile) prompt += `\nプロフィール: ${char.profile}`;
            // 関係性情報を追加
            const relationshipId = charAtLocation.status?.relationshipId;
            if (relationshipId) {
                const relationship = relationships.find(r => r.relationship_id === relationshipId);
                if (relationship) {
                    prompt += `\n現在の関係性: ${relationship.name}（${relationship.description || ''}）`;
                    // メモがあれば追加
                    if (charAtLocation.status?.memo) {
                        prompt += `\n関係性メモ: ${charAtLocation.status.memo}`;
                    }
                    // 進展条件があれば追加
                    if (relationship.next_relationship_req) {
                        prompt += `\n関係性進展条件: ${relationship.next_relationship_req}`;
                    }
                }
            }
            // キャラクターのアクション情報を追加
            const charActionIndex = charAtLocation.status?.actionIndex ?? -1;
            if (charActionIndex >= 0 && actions[charActionIndex]) {
                const charAction = actions[charActionIndex];
                prompt += `\n現在の行動: ${charAction.name}`;
                if (charAction.prompt) prompt += `（${charAction.prompt}）`;
            }
            prompt += '\n';
        }

        // 通常モード：地の文 + セリフ + 関係性変化（テンプレートから取得）
        const charName = charAtLocation?.character?.name || '';
        let formatPrompt = getPromptTemplate(promptTemplates, 'llm_004', { name: charName })
            || `以下の形式で出力してください：\n【地の文】（2-3文で状況を描写）\n${charName ? `【${charName}のセリフ】（「」付きで1-2文）` : ''}`;

        // 関係性進展条件がある場合のみ判定を追加
        if (charAtLocation) {
            const relationshipId = charAtLocation.status?.relationshipId;
            const relationship = relationships.find(r => r.relationship_id === relationshipId);
            if (relationship && relationship.next_relationship_req) {
                formatPrompt += `\n【関係性変化】このシーンで関係性進展条件を満たした場合、もしくは総合的に関係性変化が起きたと判断される場合は新しい関係性名を記載、満たしていない場合は「維持」と記載`;
                formatPrompt += `\n【関係性メモ】関係性が変化した場合は必ず記載。変化がなくてもメモ更新が必要な出来事があれば記載。キャラクター視点で50文字以内でどこで何が起きて、なぜその関係性になったのか、今後どうしていきたいか、キャラクターの感情を交えて記載。不要なら省略`;
            }
        }

        prompt += `\n${formatPrompt}`;

        // 完全版とシンプル版の両方を返す
        return {
            fullPrompt: prompt,
            simplePrompt: `状況：${situationText}`
        };
    }

    // 統合レスポンスをパース
    function parseCombinedResponse(response, charAtLocation) {
        let narrative = '';
        let dialogue = '';
        let newRelationshipName = null;
        let relationshipMemo = null;

        // 【地の文】セクションを抽出
        const narrativeMatch = response.match(/【地の文】\s*([\s\S]*?)(?=【|$)/);
        if (narrativeMatch) {
            narrative = narrativeMatch[1].trim();
        } else {
            // フォーマットが異なる場合は全体を地の文として扱う
            narrative = response.trim();
        }

        // キャラクターがいる場合、セリフセクションを抽出
        if (charAtLocation) {
            const charName = charAtLocation.character.name;
            const dialogueRegex = new RegExp(`【${charName}のセリフ】\\s*([\\s\\S]*?)(?=【|$)`);
            const dialogueMatch = response.match(dialogueRegex);
            if (dialogueMatch) {
                dialogue = dialogueMatch[1].trim();
            }
        }

        // 【関係性変化】セクションを抽出 - 関係性名を取得
        const relationshipMatch = response.match(/【関係性変化】\s*([\s\S]*?)(?=【|$)/);
        if (relationshipMatch) {
            const result = relationshipMatch[1].trim();
            // 「維持」以外の場合は関係性名として扱う
            if (!result.includes('維持')) {
                newRelationshipName = result;
            }
        }

        // 【関係性メモ】セクションを抽出
        const memoMatch = response.match(/【関係性メモ】\s*([\s\S]*?)(?=【|$)/);
        if (memoMatch) {
            // 「（〇〇文字）」などの余計なテキストを除去
            relationshipMemo = memoMatch[1].trim().replace(/[（(]\d+文字[）)]/g, '').trim();
        }

        return { narrative, dialogue, newRelationshipName, relationshipMemo };
    }

    // 会話モードレスポンスをパース
    function parseConversationResponse(response, charAtLocation) {
        let dialogue = '';
        let narrative = '';
        let newRelationshipName = null;
        let relationshipMemo = null;

        // 【キャラ名のセリフ】セクションを抽出
        if (charAtLocation) {
            const charName = charAtLocation.character.name;
            const dialogueRegex = new RegExp(`【${charName}のセリフ】\\s*([\\s\\S]*?)(?=【|$)`);
            const dialogueMatch = response.match(dialogueRegex);
            if (dialogueMatch) {
                dialogue = dialogueMatch[1].trim();
            } else {
                // フォーマットが異なる場合、【地の文】または【関係性変化】より前の部分をセリフとして扱う
                const beforeNarrative = response.split(/【地の文】|【関係性変化】/)[0].trim();
                dialogue = beforeNarrative;
            }
            // セリフから【地の文】以降を除去
            dialogue = dialogue.split(/【地の文】|【関係性変化】|【関係性メモ】/)[0].trim();
        }

        // 【地の文】セクションを抽出（最初の1行のみ）
        const narrativeMatch = response.match(/【地の文】\s*([\s\S]*?)(?=【|$)/);
        if (narrativeMatch) {
            const lines = narrativeMatch[1].trim().split('\n').filter(l => l.trim());
            narrative = lines[0] || '';
        }

        // 【関係性変化】セクションを抽出 - 関係性名を取得
        const relationshipMatch = response.match(/【関係性変化】\s*([\s\S]*?)(?=【|$)/);
        if (relationshipMatch) {
            const result = relationshipMatch[1].trim();
            // 「維持」以外の場合は関係性名として扱う
            if (!result.includes('維持')) {
                newRelationshipName = result;
            }
        }

        // 【関係性メモ】セクションを抽出
        const memoMatch = response.match(/【関係性メモ】\s*([\s\S]*?)(?=【|$)/);
        if (memoMatch) {
            // 「（〇〇文字）」などの余計なテキストを除去
            relationshipMemo = memoMatch[1].trim().replace(/[（(]\d+文字[）)]/g, '').trim();
        }

        return { dialogue, narrative, newRelationshipName, relationshipMemo };
    }

    // 構図タグ取得（共通関数を使用）
    // selectBestComposition, getCompositionTag は js/prompt-utils.js で定義

    // キャラクター画像生成（image_gen_base.htmlと同じ方式）
    async function generateCharacterImage(character, place, actionIndex) {
        const runwareApiKey = document.getElementById('runwareApiKey').value.trim();
        if (!runwareApiKey) return null;

        // モデル取得（選択されたモデルを優先、なければ最初のモデル）
        const modelId = selectedModelId || getFirstModelId(models);
        if (!modelId || !models[modelId]) {
            console.log('[画像生成] モデルが未設定');
            return null;
        }
        const model = models[modelId];

        // 構図タグを取得（BESTから選択）
        const compositionTag = getCompositionTag(actions, actionIndex);

        // プロンプト構築（image_gen_base.htmlと同じ順序）
        const parts = [
            model?.qualityPositive || '',           // 品質タグ（ポジティブ）
            character?.tag || '',                    // キャラタグ
            place?.tag || '',                        // 場所タグ
            (actionIndex >= 0 && actions[actionIndex]) ? actions[actionIndex].prompt : '',  // アクションプロンプト
            compositionTag,                          // 構図タグ（BEST選択）
            place?.additionalTag || '',              // 場所の追加タグ
            character?.additionalTag || ''           // キャラの追加タグ
        ].filter(p => p);

        if (parts.length === 0) {
            console.log('[画像生成] プロンプトが空のためスキップ');
            return null;
        }

        const prompt = cleanPrompt(parts.join(', '));
        const negativePrompt = model?.qualityNegative || '';

        console.log('[画像生成] モデル:', modelId);
        console.log('[画像生成] 構図:', compositionTag || '(なし)');
        console.log('[画像生成] プロンプト:', prompt);
        console.log('[画像生成] ネガティブ:', negativePrompt);

        const result = await generateImage(runwareApiKey, modelId, prompt, {
            negativePrompt: negativePrompt,
            steps: model?.steps || 20,
            cfgScale: model?.cfgScale || 7,
            scheduler: model?.scheduler || 'Default',
            width: 1024,
            height: 1024,
            character: character
        });

        return result.imageURL;
    }

    // ページ1用プロンプト構築
    function buildPage1Prompt(actionType, userInput, previousPlace, newPlace, charAtLocation) {
        const narratorPrompt = getPromptTemplate(promptTemplates, 'llm_005')
            || 'あなたは小説の地の文を書くナレーターです。簡潔に2-3文で状況を描写してください。';
        let prompt = narratorPrompt + '\n\n';

        const currentPlace = places[userState.placeIndex];
        prompt += `【現在の場所】${currentPlace?.name || '不明'}\n`;

        if (charAtLocation) {
            prompt += `【その場にいる人物】${charAtLocation.character.name}`;
            // 関係性情報を追加
            const relationshipId = charAtLocation.status?.relationshipId;
            if (relationshipId) {
                const relationship = relationships.find(r => r.relationship_id === relationshipId);
                if (relationship) {
                    prompt += `（関係性: ${relationship.name}`;
                    if (relationship.description) prompt += ` - ${relationship.description}`;
                    prompt += `）`;
                }
            }
            prompt += '\n';
        }

        switch (actionType) {
            case 'move':
                prompt += `【状況】主人公が「${previousPlace?.name || ''}」から「${newPlace?.name || ''}」に移動した。\n`;
                break;
            case 'speech':
                prompt += `【状況】主人公が「${userInput}」と言った。\n`;
                break;
            case 'action':
                prompt += `【状況】主人公が「${userInput}」という行為をした。\n`;
                break;
            case 'action_select':
                prompt += `【状況】主人公が「${userInput}」を行った。\n`;
                break;
            case 'action_with_speech':
                const actionName = actions[currentState.actionIndex]?.name || '';
                prompt += `【状況】主人公が「${actionName}」をしながら「${userInput}」と言った。\n`;
                break;
            case 'scenario':
                prompt += `【状況】${userInput}\n`;
                break;
        }

        prompt += '\n地の文のみを出力してください。';
        return prompt;
    }

    // LLM呼び出し（ストリーム対応・履歴付き）
    // onChunk: ストリーム受信時のコールバック (accumulatedText) => void
    async function callLLM(apiKey, prompt, role, character = null, onChunk = null, simplePrompt = null) {
        // システムプロンプト（テンプレートから取得、なければデフォルト）
        const systemPrompt = getPromptTemplate(promptTemplates, 'llm_001')
            || 'あなたは小説のシーンを描写するアシスタントです。指定された形式で簡潔に出力してください。';

        // 履歴に保存するプロンプト（シンプル版があればそれを使用）
        const historyPrompt = simplePrompt || prompt;

        // メッセージ構築（履歴 + 新しいプロンプト）
        const messages = [
            { role: 'system', content: systemPrompt },
            ...chatHistory,
            { role: 'user', content: prompt }
        ];

        console.log('[LLM] 履歴数:', chatHistory.length / 2, '往復');
        console.log('[LLM] 履歴用プロンプト:', historyPrompt);

        // GASにリクエストログを送信（ON時のみ、非同期）
        const gasUrl = document.getElementById('gasUrl').value.trim();
        if (llmLogEnabled && gasUrl) {
            const logData = [];
            logData.push({ log_key: 'model', log_value: selectedLLMModelId });
            messages.forEach((msg, i) => {
                logData.push({ log_key: `messages[${i}].role`, log_value: msg.role });
                logData.push({ log_key: `messages[${i}].content`, log_value: msg.content });
            });
            console.log('[GAS Log] 送信データ:', logData);
            saveGasData(gasUrl, 'llm_req_log', logData)
                .then(res => console.log('[GAS Log] 送信結果:', res))
                .catch(e => console.error('[GAS Log Error]', e));
        }

        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: selectedLLMModelId,
                    messages: messages,
                    stream: true
                })
            });

            if (!response.ok) {
                const error = await response.json();
                console.error('[LLM] エラー:', error);
                return 'エラーが発生しました';
            }

            // ストリーム読み取り
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let content = '';
            let buffer = '';
            let firstChunk = true;
            window._chunkLogCount = 0;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                if (firstChunk) {
                    window._streamStartTime = performance.now();
                    console.log('[LLM] ストリーム受信開始 (0.000秒)');
                    firstChunk = false;
                }

                const decodedChunk = decoder.decode(value, { stream: true });
                buffer += decodedChunk;

                // 最初の数回のチャンクをログ
                if (!window._chunkLogCount) window._chunkLogCount = 0;
                if (window._chunkLogCount < 3) {
                    const elapsed = ((performance.now() - window._streamStartTime) / 1000).toFixed(3);
                    console.log(`[LLM] チャンク受信 #${window._chunkLogCount + 1} (${elapsed}秒):`, decodedChunk.substring(0, 100));
                    window._chunkLogCount++;
                }

                // 改行で分割してSSEイベントを処理
                const lines = buffer.split('\n');
                buffer = lines.pop(); // 未完了の行はバッファに残す

                for (const line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed || !trimmed.startsWith('data:')) continue;

                    const data = trimmed.slice(5).trim();
                    if (data === '[DONE]') continue;

                    try {
                        const json = JSON.parse(data);
                        const delta = json.choices?.[0]?.delta?.content || '';
                        if (delta) {
                            content += delta;
                            // コールバックで通知
                            if (onChunk) {
                                onChunk(content);
                            }
                        }
                    } catch (e) {
                        // JSONパースエラーは無視
                    }
                }
            }

            // 履歴に追加（最大10往復 = 20メッセージ）
            // シンプル版プロンプトを履歴に保存（トークン節約）
            // レスポンスから関係性変化・関係性メモを削除
            const simpleResponse = content
                .replace(/【関係性変化】[\s\S]*?(?=【|$)/g, '')
                .replace(/【関係性メモ】[\s\S]*?(?=【|$)/g, '')
                .trim();
            chatHistory.push({ role: 'user', content: historyPrompt });
            chatHistory.push({ role: 'assistant', content: simpleResponse });

            while (chatHistory.length > 20) {
                chatHistory.shift();
                chatHistory.shift();
            }

            return content;
        } catch (error) {
            console.error('[LLM] 通信エラー:', error);
            return '通信エラーが発生しました';
        }
    }
</script>

</body>
</html>
